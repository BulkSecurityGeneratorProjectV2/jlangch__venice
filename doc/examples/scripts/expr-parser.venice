;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2022 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;; ----------------------------------------------------------------------------
;;; Parsatron expression parser example
;;; ----------------------------------------------------------------------------


;;; ----------------------------------------------------------------------------
;;; Usage
;;; ----------------------------------------------------------------------------
;;;
;;; [1] Start a REPL and load the expression parser script
;;;     (load-file "path-to-scripts/expr-parser.venice")
;;;
;;; [2] Test the Tokenizer:
;;;     (p/run (tokens) "3 + 4.2")
;;;     => ([:int "3"] [:operator "+"] [:float "4.2"] )
;;;
;;; [3] Test the Parser:
;;;     (->> (p/run (tokens) "3 + 4.1 - 5 * 3.2")
;;;          (p/run (expr))
;;;     => -8.9
;;;
;;;     (->> (p/run (tokens) "3 + (4.1 - 5) * 3.2")
;;;          (p/run (expr))
;;;     => 0.11999999999999877


;;; ----------------------------------------------------------------------------
;;; EBNF
;;; ----------------------------------------------------------------------------
;;;
;;; Tokenizer
;;; ----------------------------------------------------------------------------
;;; Whitespace          ::= ( " " | "\t" | "\n" )
;;; Operation           ::= ( "+" | "-" | "*" | "/" )
;;; LParen              ::= "("
;;; RParen              ::= ")"
;;; Digit               ::= "0" .. "9"
;;; Integer             ::= "0" | ( "1" .. "9" ) [ Digit ]*
;;; Float               ::= ( [ Digit ]+ "." [ Digit ]* | "." [ Digit ]+ )
;;;
;;; Token               ::= ( Whitespace | Operation | ParOpen | ParClose | Integer | Float)
;;; Tokens              ::= [ Token ]* EOI
;;;
;;;
;;; Parser
;;; ----------------------------------------------------------------------------
;;;
;;; Literal             ::=  Integer | Float
;;;
;;; Main                ::=  Expression EOI
;;; Expression          ::=  AddExpression
;;; AddExpression       ::=  MulExpression [ ( "+" | "-" ) MulExpression ]*
;;; MulExpression       ::=  UnaryExpression [ ( "*" | "/" ) UnaryExpression ]*
;;; UnaryExpression     ::=  ( "+" | "-" ) UnaryExpression | ParExpression | Literal
;;; ParExpression       ::=  "(" Expression ")"



(load-module :parsatron)
(ns-alias 'p 'parsatron)


;;; ----------------------------------------------------------------------------
;;; Token
;;; ----------------------------------------------------------------------------

(deftype :Token [type :keyword, val :string]
  Object
    (toString [this] (str/format "[%s %s]"
                                 (pr-str (:type this))
                                 (pr-str (:val this)))))

(defn token-type? [token type]
  (= type (:type token)))

(defn token-value? [token value]
  (= value (:val token)))

(defn token? [token type value]
  (and (= type (:type token)) (= value (:val token))))

(defn remove-whitespaces [tokens]
  (filter #(not (token-type? % :whitespace)) tokens))


;;; ----------------------------------------------------------------------------
;;; Tokenizer
;;; ----------------------------------------------------------------------------

(p/defparser ws []
  (p/let->> [t (p/choice (p/char #\space) (p/char #\newline) (p/char #\tab))]
     (p/always (Token. :whitespace (str t)))))

(p/defparser operator []
  (p/let->> [t (p/choice (p/char #\+) (p/char #\-) (p/char #\*) (p/char #\/))]
     (p/always (Token. :operator (str t)))))

(p/defparser lparen []
  (p/let->> [t (p/choice (p/char #\lparen))]
     (p/always (Token. :lparen (str t)))))

(p/defparser rparen []
  (p/let->> [t (p/choice (p/char #\rparen))]
     (p/always (Token. :rparen (str t)))))

(p/defparser digit-1to9 []
  (p/choice (p/char #\1) (p/char #\2) (p/char #\3)
                         (p/char #\4) (p/char #\5) (p/char #\6)
                         (p/char #\7) (p/char #\8) (p/char #\9)))

(p/defparser integer []
  (p/attempt (p/either (p/let->> [_ (p/char #\0)]
                          (p/always (Token. :int "0")))
                       (p/let->> [f (digit-1to9)
                                  r (p/many (p/digit))]
                          (p/always (Token. :int (apply str (list* f r))))))))

(p/defparser float []
  (p/attempt (p/let->> [i-tok (integer)
                        _     (p/char #\.)
                        f     (p/many1 (p/digit))]
                (let [i (:val i-tok)]
                  (p/always (Token. :float
                                    (apply str (flatten (list* i #\. f)))))))))

(p/defparser token []
  (p/choice (ws) (operator) (lparen) (rparen) (float) (integer)))

(p/defparser tokens []
  (p/let->> [toks (p/many (token))
             _    (p/eof)]
     (p/always (remove-whitespaces (list* toks)))))


;;; ----------------------------------------------------------------------------
;;; Parser
;;; ----------------------------------------------------------------------------

(defn op [sym]
  (p/token #(token? % :operator sym)))

(defn l-paren []
  (p/token #(token-type? % :lparen)))

(defn r-paren []
  (p/token #(token-type? % :rparen)))

(p/defparser nint []
  (p/let->> [i (p/token #(token-type? % :int))]
     (p/always (long (:val i)))))

(p/defparser nfloat []
 (p/let->> [i (p/token #(token-type? % :float))]
    (p/always (double (:val i)))))

(p/defparser number []
  (p/either (nint) (nfloat)))


(p/defparser expr [] (add-expr))

(p/defparser add-expr []
  (p/let->> [seed (mul-expr)
             rst  (p/many (p/let->> [op_ (p/either (op "+") (op "-"))
                                     val (mul-expr)]
                             (p/always [(:val op_) val])))]
      (p/always (reduce (fn [acc x]
                          (let [op_ (resolve (symbol (first x)))]
                            (op_ acc (second x))))
                        seed
                        rst))))

(p/defparser mul-expr []
  ;; "3 * 4", "-3 * 4", "3 * 4 * 5"
  (p/let->> [seed (unary-expr)
             rst  (p/many (p/let->> [op_ (p/either (op "*") (op "/"))
                                     val (unary-expr)]
                             (p/always [(:val op_) val])))]
      (p/always (reduce (fn [acc x]
                          (let [op_ (resolve (symbol (first x)))]
                            (op_ acc (second x))))
                        seed
                        rst))))

(p/defparser unary-expr []
  ;; "3", "+3", "-3"
  (p/choice (p/let->> [op_ (p/either (op "+") (op "-"))
                       val (unary-expr)]
               (p/always (if (token-value? op_ "+") val (negate val))))
            (par-expr)
            (number)))

(p/defparser par-expr []
  (p/between (l-paren) (r-paren) (expr)))
