
(defmacro
   { :arglists '(& body)
     :doc "Ignores body, yields nil" }
    
   comment [& body] nil)


(defmacro 
   { :arglists '(expr message?)
     :doc "Evaluates expr and throws an exception if it does not evaluate " + 
		  "to logical true." }

   assert [expr message]
   `(if ~message
       (when-not ~expr
           (throw (. :com.github.jlangch.venice.AssertionException 
                     :new 
                     (str "Assert failed (" ~message "): " (pr-str '~expr)))))
       (when-not ~expr
           (throw (. :com.github.jlangch.venice.AssertionException 
                     :new 
                     (str "Assert failed: " (pr-str '~expr)))))
    ))
    

(defmacro 
   { :arglists '(& pred-forms)
     :doc "Ands the predicate forms" }

   and [x & next]
    (let [arity_ (inc (count next))]
        `(if (== 1 ~arity_)
            ~x  
            (let [cond_ ~x]
                (if cond_ (and ~@next) cond_)))))


(defmacro 
   { :arglists '(& pred-forms)
     :doc "Ors the predicate forms" }

   or [x & next]
    (let [arity_ (inc (count next))]
        `(if (== 1 ~arity_)
            ~x 
            (let [cond_ ~x]
                (if cond_ cond_ (or ~@next))))))


(defmacro 
   { :arglists '(& clauses)
     :doc 
     	"Takes a set of test/expr pairs. It evaluates each test one at a " + 
		"time.  If a test returns logical true, cond evaluates and returns " + 
		"the value of the corresponding expr and doesn't evaluate any of the " + 
		"other tests or exprs. (cond) returns nil." }

   cond [& clauses]
    (when clauses 
        (list 'if (first clauses) 
            (if (rest clauses) 
                (second clauses) 
                (throw "cond requires an even number of forms")) 
            (cons 'cond (rest (rest clauses))))))


(defmacro 
   { :arglists '(test & body)
     :doc "Evaluates test. If logical true, evaluates body in an implicit do." }

   when [test & body]
    (list 'if test (cons 'do body)))


(defmacro 
   { :arglists '(test & body)
     :doc "Evaluates test. If logical false, evaluates body in an implicit do." }

   when-not [test & body]
    (list 'if test nil (cons 'do body)))


(defmacro 
   { :arglists '(bindings then else)
     :doc 
     	"bindings is a vector with 2 elements: binding-form test. \n" + 
		"If test is true, evaluates then with binding-form bound to the value of " + 
		"test, if not, yields else" }

   if-let [bindings then else]
   (let [form (first bindings) tst (second bindings)]
     `(let [temp_ ~tst]
        (if temp_
          (let [~form temp_]
            ~then)
          ~else))))


(defmacro 
   { :arglists '(bindings & body)
     :doc "Repeatedly executes body with name bound to integers from 0 through n-1." }

   dotimes [bindings & body]
    (let [i (first bindings) 
          n (second bindings)] 
       `(let [k (long ~n)] 
           (loop [~i 0] 
              (when (< ~i k) 
                 ~@body 
                 (recur (inc ~i)))))))


(defmacro 
   { :arglists '(test & body)
     :doc 
     	"Repeatedly executes body while test expression is true. Presumes " +
		"some side-effect will cause test to become false/nil. Returns nil" }

   while [test & body]
    `(loop [] 
        (when ~test 
            ~@body 
            (recur))))


(defmacro 
   { :arglists '(x & forms)
     :doc 
     	"Evaluates x then calls all of the methods and functions with the " + 
		"value of x supplied at the front of the given arguments.  The forms " + 
		"are evaluated in order. Returns x." 
	 :examples 
	 	'("(doto (. :java.util.HashMap :new) \n" +
		  "      (. :put :a 1) \n" +
		  "      (. :put :b 2))") }

   doto [x & forms]
    (let [gx (gensym)] 
       `(let [~gx ~x] 
          ~@(map (fn [f] `(~(first f) ~gx ~@(rest f))) forms) 
          ~gx)))


(defmacro 
   { :arglists '(x & forms)
     :doc 
     	"Threads the expr through the forms. Inserts x as the " + 
		"second item in the first form, making a list of it if it is not a " + 
		"list already. If there are more forms, inserts the first form as the " + 
		"second item in second form, etc." 
	 :examples '("(-> 5 (+ 3) (/ 2) (- 1))") }

   -> [x & forms]
    (loop [x x, forms forms]
        (if forms
            (let [form (first forms)
                  threaded (if (list? form)
                              `(~(first form) ~x ~@(empty-to-nil(rest form)))
                              (list form x))]
               (recur threaded (empty-to-nil(rest forms))))
            x)))


(defmacro 
   { :arglists '(x & forms)
     :doc 
     	"Threads the expr through the forms. Inserts x as the " + 
		"last item in the first form, making a list of it if it is not a " + 
		"list already. If there are more forms, inserts the first form as the " + 
		"last item in second form, etc." 
	 :examples 
	 	'("(->> 5 (+ 3) (/ 32) (- 1))"
	 	
		  "(->> [ {:a 1 :b 2} {:a 3 :b 4} {:a 5 :b 6} {:a 7 :b 8} ] \n" +
		  "     (map (fn [x] (get x :b))) \n" +
		  "     (filter (fn [x] (> x 4))) \n" +
		  "     (map inc)))) ") }

   ->> [x & forms]
    (loop [x x, forms forms]
        (if forms
            (let [form (first forms)
                  threaded (if (list? form)
                         `(~(first form) ~@(empty-to-nil(rest form)) ~x)
                         (list form x))]
               (recur threaded (empty-to-nil(rest forms))))
            x)))


(defmacro 
   { :arglists '(seq-exprs body-expr)
     :doc 
     	"List comprehension. Takes a vector of one or more " + 
		"binding-form/collection-expr pairs, each followed by zero or more " + 
		"modifiers, and yields a collection of evaluations of expr. " + 
		"Supported modifiers are: :when test." 
	 :examples 
	 	'("(list-comp [x (range 10)] x)"
		  "(list-comp [x (range 5)] (* x 2))"
		  "(list-comp [x (range 10) :when (odd? x)] x)"
		  "(list-comp [x (range 10) :when (odd? x)] (* x 2))"
		  "(list-comp [x (list \"abc\") y [0 1 2]] [x y])") }

   list-comp [[binding coll-expr & bindings] body-expr]
    (cond (not binding)
        `(list ~body-expr)

        (== :when binding)
        `(when ~coll-expr (list-comp ~bindings ~body-expr))

        :else
        `(mapcat (fn [~binding] (list-comp ~bindings ~body-expr))
                 ~coll-expr)))


(defmacro 
   { :arglists '(expr)
     :doc "Evaluates expr and prints the time it took.  Returns the value of expr." }

   time [expr]
    `(let [start_ (time-ns)
           ret_ ~expr]
         (prn (str "Elapsed time: " (/ (- (time-ns) start_) 1000000) " msecs"))
         ret_))


(def load-file (fn [f] (eval (read-string (str "(do " (slurp f) ")")))))


(def load-string (fn [s] (eval (read-string (str "(do " s ")")))))


(def not (fn [x] (if x false true)))


(def 
   { :arglists '(x)
     :doc "Returns its argument." }
     
   identity (fn [x] x))


(def zipmap (fn [keys vals]
   (loop [map (ordered-map)
          ks (seq keys)
          vs (seq vals)]
      (if (and (not-empty? ks) (not-empty? vs))
         (recur (assoc map (first ks) (first vs))
                (rest ks)
                (rest vs))
         map))))


(def memoize (fn [f]
   (let [mem (atom {})]
      (fn [& args]
         (if-let [e (find @mem args)]
            (val e)
            (let [ret (apply f args)]
               (swap! mem assoc args ret)
               ret))))))
 
 
;; JSON utils (requires Jackson JSON on classpath)
(def json/pretty-print (fn [json]
   (json/to-pretty-json (json/parse json))))
   
(def json/to-json (fn [val]
    (-> (. :com.fasterxml.jackson.databind.ObjectMapper :new)
        (. :writeValueAsString val))))
   
(def json/to-pretty-json (fn [val]
    (-> (. :com.fasterxml.jackson.databind.ObjectMapper :new)
        (. :writerWithDefaultPrettyPrinter)
        (. :writeValueAsString val))))

(def json/parse (fn [text]
    (-> (. :com.fasterxml.jackson.databind.ObjectMapper :new)
        (. :readValue text (class-for-name :java.lang.Object)))))


