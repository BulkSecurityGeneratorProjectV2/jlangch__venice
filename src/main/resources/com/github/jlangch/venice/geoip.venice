;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2020 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; GEOIP functions. Maps IP adresses to country and city


;;;; ---------------------------------------------------------------------------
;;;;
;;;;                        W O R K   I N    P R O G R E S S
;;;;
;;;; ---------------------------------------------------------------------------

(ns geoip)

(load-module :csv)


(def geoip/geolite-country-url "http://geolite.maxmind.com/download/geoip/database/GeoLite2-Country-CSV.zip")

(def geoip/ip4-file "GeoLite2-Country-Blocks-IPv4.csv")
(def geoip/ip6-file "GeoLite2-Country-Blocks-IPv6.csv")
(def geoip/country-file "GeoLite2-Country-Locations-en.csv")


(defn geoip/download-country-db-to-file [zip-file]
  (io/spit zip-file (geoip/download-country-db)))

(defn geoip/download-country-db []
  (io/download geoip/geolite-country-url :binary true))

(defn- geoip/unzip-entry [zip name]
  (let [entry (->> (io/zip-list-entry-names zip)
                   (filter #(str/ends-with? % name))
                   (first))]
    (io/unzip (io/file zip) entry)))

(defn- geoip/parse-file [zip name]
  (-<> (geoip/unzip-entry zip name)
       (bytebuf-to-string <> :utf-8)
       (csv/read <>)))

(defn- geoip/parse-ip [zip file countries]
  (let [ip-data (->> (geoip/parse-file zip file)
                     (filter #(and (not (nil? (nth % 2)))
                                   (= "0" (nth % 4))
                                   (= "0" (nth % 5)))))]
    (if (some? countries)
      (into {} (map (juxt #(nth % 0) #(get countries (nth % 2))) ip-data)) ; map network -> country-name
      (map (fn [x] { :id (nth x 1)
                          :network (nth x 0)
                          :country-id (nth x 2) }) ip-data))))

(defn geoip/ip4? [ip]
  (case (type ip)
    :venice.String         (str/contains? ip ".")
    :java.net.Inet4Address true
    :java.net.Inet6Address false
    false))

(defn geoip/ip6? [ip]
  (case (type ip)
    :venice.String         (str/contains? ip ":")
    :java.net.Inet4Address false
    :java.net.Inet6Address true
    false))

(defn geoip/parse-countries [zip]
  (->> (geoip/parse-file zip geoip/country-file)
       (map (juxt #(nth % 0) #(nth % 5))) ; map country-id -> country-name
       (into {})))

(defn geoip/parse-ip4
  ([zip] (geoip/parse-ip zip geoip/ip4-file nil))
  ([zip countries] (geoip/parse-ip zip geoip/ip4-file countries)))

(defn geoip/parse-ip6
  ([zip] (geoip/parse-ip zip geoip/ip6-file nil))
  ([zip countries] (geoip/parse-ip zip geoip/ip6-file countries)))
