;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2020 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; The Mercator projection is a cylindrical map projection. It can be used
;;;; to map IP locations to a world map.
;;;;
;;;; See: https://en.wikipedia.org/wiki/Mercator_projection
;;;;
;;;; World coordinates are given by a latitude and a longitude.
;;;;
;;;; Latitude specifies the north-south position of a point on the Earth's
;;;; surface. Latitude is an angle which ranges from 0° at the equator to +90°
;;;; at north and -90° at south pole.
;;;;
;;;; Longitude specifies the east-west position of a point on the Earth's
;;;; surface. Longitude is an angle which ranges from 0° at the prime meridian
;;;; to +180° eastward and -180° westward.
;;;;
;;;; The formulas are taken from:
;;;; https://en.wikipedia.org/wiki/Web_Mercator_projection
;;;;
;;;; A square Mercator map with a latitude range -85.0° to + 85.0°:
;;;; https://upload.wikimedia.org/wikipedia/commons/7/73/Mercator_projection_Square.JPG
;;;;
;;;; Resources:
;;;; https://en.m.wikipedia.org/wiki/World_Geodetic_System#A_new_World_Geodetic_System:_WGS_84
;;;; https://www.glk.uni-mainz.de/files/2018/08/FB08_Masterarbeit_PaulWeber.pdf
;;;;
;;;;
;;;; Example:
;;;;
;;;;      (do
;;;;        (load-module :mercator)
;;;;
;;;;        (-> (mercator/load-mercator-image)
;;;;            (mercator/draw-locations (vals mercator/cities))
;;;;            (mercator/crop-image 400 600)
;;;;            (mercator/save-image :png "./test-map.png")))
;;;;


(ns mercator)

(import :javax.imageio.ImageIO)
(import :java.awt.Color)
(import :java.awt.RenderingHints)
(import :java.net.URL)
(import :com.github.jlangch.venice.javainterop.proxy.Graphics2DComposite)


;; Some cities (https://www.laengengrad-breitengrad.de/)
(def cities
  { :zurich     [ 47.37174       8.54226  ]
    :new-york   [ 40.712778    -74.005833 ]
    :tokyo      [ 35.6894875   139.6917064]
    :perth      [-31.953513    115.857047 ]
    :honolulu   [ 21.3069444  -157.8583333]
    :montevideo [-34.9011127   -56.1645314]
    :greenwich  [ 51.482577      0.0      ]
    :reykjavik  [ 64.13548     -21.89541  ]
    :kapstadt   [-33.924869     18.424055 ]
    :zero       [  0.0           0.0      ] })


(def mercator-map "https://upload.wikimedia.org/wikipedia/commons/7/73/Mercator_projection_Square.JPG")

;; major and the minor radius of Earth measured in meters
(def earth-radius-major 6378137.0)
(def earth-radius-minor 6356752.3142)

(def pi (. :java.lang.Math :PI))

(def latitude-range [-85.0 85.0])

;; spherical mercator projection bounding box based on the
;; latitude range [-85.0 85.0]
(def spherical-box
  { :top     19971868.88
    :right   20037508.34
    :bottom -19971868.88
    :left   -20037508.34 })

;; elliptical mercator projection bounding box based on the
;; latitude range [-85.0 85.0]
(def elliptical-box
  { :top     19929239.11
    :right   20037508.34
    :bottom -19929239.11
    :left   -20037508.34 })

(def bitmap-format
  { :png  "PNG"
    :gif  "GIF"
    :bmp  "BMP"
    :jpg  "JPG" })



(defn- limit [val [lower upper]]
  (min upper (max lower val)))

(defn spherical-x-axis [longitude]
  (* (to-radians longitude) earth-radius-major))

(defn spherical-y-axis [latitude]
  (-<> (to-radians (limit latitude latitude-range))
       (/ <> 2.0)
       (+ <> (/ pi 4.0))
       (tan <>)
       (log <>)
       (* <> earth-radius-major)))

(defn elliptical-x-axis [longitude]
  (* (to-radians longitude) earth-radius-major))

(defn elliptical-y-axis [latitude]
  (let [latitude-radians
            (to-radians (limit latitude latitude-range))
        earth-dimensional-rate-normalized
            (- 1.0  (square (/ earth-radius-minor earth-radius-major)))
        latitude-on-earth-proj
            (* (sqrt earth-dimensional-rate-normalized)
               (sin latitude-radians))
        latitude-on-earth-proj
            (pow (/ (- 1.0 latitude-on-earth-proj)
                    (+ 1.0 latitude-on-earth-proj))
                 (* 0.5 (sqrt earth-dimensional-rate-normalized)))
        latitude-on-earth-proj-normalized
            (/ (tan (* 0.5 (- (* pi 0.5) latitude-radians)))
               latitude-on-earth-proj)]
      (* -1.0 earth-radius-major (log latitude-on-earth-proj-normalized))))

(defn x-axis-normalize [x box]
  (/ (- x (:left box))
     (- (:right box) (:left box))))

(defn y-axis-normalize [y box]
  (/ (- y (:bottom box))
     (- (:top box) (:bottom box))))

(defn spherical-mapper [map-width map-height]
  (fn [longitude latitude]
    { :longitude longitude
      :latitude latitude
      :x (long (* map-width (x-axis-normalize (spherical-x-axis longitude)
                                              spherical-box)))
      :y (long (* map-height (y-axis-normalize (spherical-y-axis latitude)
                                               spherical-box))) }))

(defn elliptical-mapper [map-width map-height]
  (fn [longitude latitude]
    { :longitude longitude
      :latitude latitude
      :x (long (* map-width (x-axis-normalize (elliptical-x-axis longitude)
                                              elliptical-box)))
      :y (long (* map-height (y-axis-normalize (elliptical-y-axis latitude)
                                               elliptical-box))) }))

(defn load-mercator-image []
  (. :ImageIO :read (. :URL :new mercator-map)))

(defn color [r g b a]
  (. :Color :new (int r) (int g) (int b) (int a)))

(defn load-image [file]
  (. :ImageIO :read (io/file file)))

(defn save-image [image format file]
  (. :ImageIO :write image (get bitmap-format format) (io/file file)))

(defn image-dimensions [image]
  [ (. image :getWidth nil) (. image :getHeight nil)])

(defn crop-image [image crop-top crop-bottom]
  (let [[width height] (image-dimensions image)]
    (. image :getSubimage 0 crop-top width (- height crop-top crop-bottom))))

(defn draw-circle [image x y radius fill-color border-color]
  (let [g (delegate :Graphics2DComposite (. image :createGraphics))]
    (. g :setRenderingHints { (. :RenderingHints :KEY_ANTIALIASING)
                              (. :RenderingHints :VALUE_ANTIALIAS_ON) } )
    (. g :setColor fill-color)
    (. g :fillOval (- x radius) (- y radius) (* 2 radius) (* 2 radius))
    (. g :setColor border-color)
    (. g :drawOval (- x radius) (- y radius) (* 2 radius) (* 2 radius)))
  image)

(defn draw-locations [image locations]
  (let [[img-width img-height] (image-dimensions image)
        fill-color (color 255 128 128 255)
        border-color (color 255 0 0 255)
        radius 10
        mapper (spherical-mapper img-width img-height)
        render (fn [pos] (draw-circle image
                                      (:x pos)
                                      (- img-height (:y pos))
                                      radius
                                      fill-color
                                      border-color))]
    (docoll (fn [l] (render (mapper (second l) (first l)))) locations))
  image)

(defn test []
  (-> (load-mercator-image)
      (draw-locations (vals cities))
      (crop-image 400 600)
      (save-image :png "test-cities.png")))
