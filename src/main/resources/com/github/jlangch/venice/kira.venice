;;;   __    __         _
;;;   \ \  / /__ _ __ (_) ___ ___
;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;     \  /  __/ | | | | (_|  __/
;;;      \/ \___|_| |_|_|\___\___|
;;;
;;;
;;; Copyright 2017-2019 Venice
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions and
;;; limitations under the License.

;;;  Kira - a simple templating library
;;;
;;; Thanks to James Reeves and his clojure 'comb' project
;;; (https://github.com/weavejester/comb). Venice's Kira
;;; templating library builds on the ideas of 'comb'.

;; -----------------------------------------------------------------------------
;; Framework functions
;; -----------------------------------------------------------------------------
(defn- kira/read-source [source]
  (if (string? source)
    source
    (io/slurp source)))

(def kira/delimiters ["<%" "%>"])

(defn
  kira/parser-regex
  [delimiters]
  (regex/pattern
        (str "(?s)\\A"
             "(?:" "(.*?)"
             "\\Q" (first delimiters) "\\E" "(.*?)" "\\Q" (last delimiters) "\\E"
             ")?"
             "(.*)\\z")))

(def kira/parser-regex-memo (memoize kira/parser-regex))

(defn kira/emit-string [s]
  (when (not-empty? s)
    (print (str "(print " (pr-str s) ")"))))

(defn kira/emit-expr [expr]
  (if (str/starts-with? expr "=")
    (print (str "(print " (str/trim (str/subs expr 1)) ")"))
    (print expr)))

(defn kira/parse-string [source delimiters]
  (let [regex (kira/parser-regex delimiters)]
    (with-out-str
      (print "(do ")
      (loop [src source]
        (let [[_ before expr after] (regex/matches regex src)]
          (if expr
            (do (kira/emit-string before)
                (kira/emit-expr expr)
                (recur after))
            (do (kira/emit-string after)
                (print ")"))))))))

(defn kira/compile-fn [args src delimiters]
  (eval
   `(fn ~args
      (with-out-str
        ~(-> src kira/read-source (kira/parse-string delimiters) read-string)))))


;; -----------------------------------------------------------------------------
;; Public functions
;; -----------------------------------------------------------------------------

(defn
  ^{ :doc "Emit a string" }
  kira/emit [s] (print (str s)))

(defn
  ^{ :doc (str/strip-indent """\
        XML escapes a string and emits it. If the passed data is not of
        type string it will be converted first to a string using the
        'str' function.
        An optional function f transforms the string before being escaped.""" ) }
  kira/escape-xml
  ([s]   (kira/escape-xml s identity))
  ([s f] (kira/emit (str/escape-xml (str (f s))))))

(defn
  ^{ :doc (str/strip-indent """\
        XML escapes a multi-line string. Splits the string into lines, XML
        escapes each line, applies the mapping function f to each line, and
        emits the joined lines""" ) }
  kira/escape-xml-multiline
  [s f] (->> (str/split-lines s)
             (map #(str/escape-xml %))
             (map #(f %))
             (str/join)
             (kira/emit)))

(defn
  ^{ :doc "Applies the function f to the items of the collection." }
  kira/docoll [coll f] (docoll f coll))

(defmacro
  ^{ :doc (str/strip-indent """\
        Compile a template into a function that takes the supplied arguments.
        The template source may be a string, or an I/O source such as a File,
        Reader or InputStream.""" ) }
  kira/fn
  ([args source]
    `(kira/compile-fn '~args ~source ~kira/delimiters))
  ([args source delimiters]
    `(kira/compile-fn '~args ~source ~delimiters)))

(defn
  ^{ :doc (str/strip-indent """\
        Evaluate a template using the supplied bindings. The template source
        may be a string, or an I/O source such as a File, Reader or
        InputStream.""" ) }
  kira/eval
  ([source]
     (kira/eval source kira/delimiters {}))
  ([source bindings]
     (kira/eval source kira/delimiters bindings))
  ([source delimiters bindings]
     (let [keys (map (comp symbol name) (keys bindings))
           func (kira/compile-fn [{:keys (into [] keys)}] source delimiters)]
        (func bindings))))
