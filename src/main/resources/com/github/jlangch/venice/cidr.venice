;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2020 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; CIDR (Classless Inter-Domain Routing) block functions. Parses CIDR
;;;; IP notations to IP address ranges. It supports both IPv4 and IPv6.
;;;;
;;;; See: https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing
;;;;
;;;; CIDR tool: // https://www.ipaddressguide.com/cidr


(ns cidr)

(import :java.math.BigInteger)
(import :java.net.InetAddress)
(import :java.nio.ByteBuffer)

(defn
  ^{ :arglists '("(cidr/parse cidr)")
     :doc "Parses CIDR specifications to an IP address range. Supports both IPv4 and IPv6."
     :examples '(
          """
          (cidr/parse "222.192.0.0/11")
          """,
          """
          (cidr/parse "2001:0db8:85a3:08d3:1319:8a2e:0370:7347/64")
          """ ) }

  cidr/parse [cidr]

  (when-not (str/contains? cidr "/")
    (throw (. :VncException :new "Not a valid CIDR format!")))

  (try
    (let [index         (str/index-of cidr "/")
          address-part  (str/subs cidr 0 index)
          network-part  (str/subs cidr (inc index))
          inet-address  (. :InetAddress :getByName address-part)
          prefix-length (long network-part)
          ip4?          (= (count (. inet-address :getAddress)) 4)
          target-size   (if ip4? 4 16)
          mask-buffer   (bytebuf-allocate target-size)]

      (if ip4?
        (bytebuf-put-int! mask-buffer -1I)
        (do (bytebuf-put-long! mask-buffer -1)
            (bytebuf-put-long! mask-buffer -1)))

      (let [mask      (-> (. :BigInteger :new 1 mask-buffer)
                          (. :not)
                          (. :shiftRight prefix-length))
            buffer    (bytebuf (. inet-address :getAddress))
            ip-val    (. :BigInteger :new 1 buffer)
            start-ip  (. ip-val :and mask)
            end-ip    (. start-ip :add (. mask :not))]

        { :cidr     cidr
          :start-ip (. :InetAddress :getByAddress
                       (cidr/pad-bytebuf (bytebuf (. start-ip :toByteArray)) target-size))
          :end-ip   (. :InetAddress :getByAddress
                       (cidr/pad-bytebuf (bytebuf (. end-ip :toByteArray)) target-size))
        } ))
    (catch :java.net.UnknownHostException ex
           (throw (. :VncException :new (str "Unknown host. CIDR=" cidr) ex)))))


(defn
  ^{ :arglists '("(cidr/in-range? ip cidr)")
     :doc """
          Returns true if the ip is within the ip range of the cidr else false.
          ip may be a string or a :java.net.InetAddress, cidr may be a string
          or a cidr map obtained from 'cidr/parse'.
          """
     :examples '(
          """
          (cidr/in-range? "222.220.0.0" "222.220.0.0/11")
          """,
          """
          (cidr/in-range? (. :InetAddress :getByName "222.220.0.0") "222.220.0.0/11")
          """,
          """
          (cidr/in-range? "222.220.0.0" (cidr/parse "222.220.0.0/11"))
          """,
          """
          (cidr/parse "2001:0db8:85a3:08d3:1319:8a2e:0370:7347/64")
          """ ) }

  in-range? [ip cidr]

  (cond
    (string? ip)
        (cidr/in-range? (. :InetAddress :getByName ip) cidr)

    (instance? :java.net.InetAddress ip)
        (let [cidr_ (cond
                      (map? cidr)     cidr
                      (string? cidr)  (cidr/parse cidr)
                      :else           (throw (. :VncException :new
                                                "Invalid cidr data type! Expected string or map.")))
              start  (. :BigInteger :new 1 (. (:start-ip cidr_) :getAddress))
              end    (. :BigInteger :new 1 (. (:end-ip cidr_) :getAddress))
              target (. :BigInteger :new 1 (. ip :getAddress))]

          (and (>= (. target :compareTo start) 0)
               (<= (. target :compareTo end) 0)))

    (throw (. :VncException :new
               (str "Invalid ip data type! "
                    "Expected string or :java.net.InetAddress but got "
                    "'" (type ip) "'")))))


(defn- cidr/pad-bytebuf [source-buf target-size]
  (let [source-size (count source-buf)
        len (if (> source-size target-size) target-size source-size)
        off (if (> source-size target-size) (- source-size target-size) 0)]
    (-> (bytebuf-allocate target-size)
        (bytebuf-pos! (- target-size len))
        (bytebuf-put-buf! source-buf off len))))
