;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2020 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; Venice tracing functions


(ns trace)


(def-dynamic ^{ :private true } *trace-depth* 0)

(def-dynamic ^{ :private true } *trace-str-limit* 80)


(defmacro
  ^{ :arglists '("(qualified-name v)")
     :doc "Returns the qualified symbol name of a var"
     :examples (list "(trace/qualified-name +)" ) }

  qualified-name [v] `(str (var-ns ~v) "/" (var-name ~v)))


(defn- limit [s]
  (str/truncate s *trace-str-limit* "..."))


(defn- tracer [name value]
  (println (str "TRACE" (when name (str " " name)) ": " (limit value))))


(defn- trace-indent []
  (apply str (repeat *trace-depth* "| ")))


(defn trace-fn-call [name f args]
  (let [id (gensym "t")]
    (tracer id (str (trace-indent) (pr-str (cons name args))))
    (binding [*trace-depth* (inc *trace-depth*)]
      (let [result (apply f args)]
        (tracer id (str (trace-indent) "=> " (pr-str result)))
        result))))


(defn
  ^{ :arglists '(
        "(trace val)",
        "(trace name val)")
     :doc
        """
        Sends name (optional) and value to the tracer function, then
        returns value. May be wrapped around any expression without
        affecting the result.
        """
     :examples (list
        """(trace/trace (+ 1 2))"""
        """(trace/trace "add" (+ 1 2))"""
        """(* 4 (trace/trace (+ 1 2)))""" ) }

  trace

  ([value] (trace nil value))
  ([name value]
     (tracer name (limit (pr-str value)))
     value))


(defmacro
  ^{ :arglists '("(traced? v)")
     :doc "Returns true if the given var is currently traced, false otherwise"
     :examples (list "(trace/traced? +)" ) }

  traced? [v]

  `(let [n (trace/qualified-name ~v)
         f (var-get (symbol n))]
    (and (fn? f) (-> f meta :traced nil? not))))


(defmacro
  ^{ :arglists '("(traceable? v)")
     :doc "Returns true if the given var can be traced, false otherwise"
     :examples (list "(trace/traceable? +)" ) }

  traceable? [v]

  `(let [n (trace/qualified-name ~v)
         f (var-get (symbol n))]
    (and (fn? f) (-> f meta :traced not))))


(defmacro
  ^{ :arglists '("(trace-var v)")
     :doc "Traces the var"
     :examples (list "(trace/trace-var +)" ) }

  trace-var [v]

  `(let [n (trace/qualified-name ~v)
         f (var-get (symbol n))]
    (if (and (fn? f) (-> f meta :traced not))
      (let [wrapper (fn tracing-wrapper [& args]
                      (trace/trace-fn-call (symbol n) f args))]
        (vary-meta wrapper assoc :traced f)
        (set! (symbol n) wrapper)
        :traced))))


(defmacro
  ^{ :arglists '("(trace-var v)")
     :doc "Untraces the var"
     :examples (list "(trace/untrace-var +)" ) }

  untrace-var [v]

  `(let [n (trace/qualified-name ~v)
        f (var-get (symbol n))]
    (if (fn? f)
      (when-let [delegate (-> f meta :traced)]
        (set! (symbol n) delegate)
        :untraced))))
