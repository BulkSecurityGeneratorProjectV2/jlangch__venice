;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2020 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; Venice tracing functions


(ns trace)


(def-dynamic ^{ :private true } *trace-depth* 0)


(defmacro
  ^{ :arglists '("(qualified-name v)")
     :doc "Returns the qualified symbol name of a var"
     :examples (list "(qualified-name +)" ) }

  qualified-name [v] `(str (var-ns ~v) "/" (var-name ~v)))


(defn- limit [s]
  (str/truncate s 60 "..."))


(defn- tracer [name value]
  (println (str "TRACE" (when name (str " " name)) ": " value)))


(defn- trace-indent []
  (apply str (repeat *trace-depth* "| ")))


(defn trace-fn-call [name f args]
  (let [id (gensym "t")]
    (tracer id (str (trace-indent) (limit (pr-str (cons name args)))))
    (binding [*trace-depth* (inc *trace-depth*)]
      (let [result (apply f args)]
        (tracer id (str (trace-indent) "=> " (limit (pr-str result))))
        result))))


(defn
  ^{ :arglists '(
        "(trace val)",
        "(trace name val)")
     :doc
        """
        Sends name (optional) and value to the tracer function, then
        returns value. May be wrapped around any expression without
        affecting the result.
        """
     :examples (list
        """(trace (+ 1 2))"""
        """(trace "add" (+ 1 2))"""
        """(* 4 (trace (+ 1 2)))""" ) }

  trace

  ([value] (trace nil value))
  ([name value]
     (tracer name (limit (pr-str value)))
     value))


(defmacro traced? [v]
 `(let [n (trace/qualified-name ~v)
        f (var-get (symbol n))]
    (and (fn? f) (-> f meta :traced nil? not))))


(defmacro traceable? [v]
 `(let [n (trace/qualified-name ~v)
        f (var-get (symbol n))]
    (and (fn? f) (-> f meta :traced not))))


(defmacro trace-var [v]
 `(let [n (trace/qualified-name ~v)
        f (var-get (symbol n))]
    (if (and (fn? f) (-> f meta :traced not))
      (let [wrapper (fn tracing-wrapper [& args]
                      (trace/trace-fn-call (symbol n) f args))]
        (vary-meta wrapper assoc :traced f)
        (set! (symbol n) wrapper)))))


(defmacro untrace-var [v]
 `(let [n (trace/qualified-name ~v)
        f (var-get (symbol n))]
    (if (fn? f)
      (when-let [delegate (-> f meta :traced)]
        (set! (symbol n) delegate)))))
