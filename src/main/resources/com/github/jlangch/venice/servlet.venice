;; J2EE Servlet

(import :com.github.jlangch.venice.impl.servlet.IVeniceServlet
        :com.github.jlangch.venice.impl.servlet.VeniceServlet
        :com.github.jlangch.venice.impl.servlet.FilterOutputStreamCloseCB
        :java.io.BufferedWriter
        :java.io.OutputStreamWriter
        :java.lang.RuntimeException
        :java.lang.NullPointerException
        :java.util.Collections
        :javax.servlet.ServletConfig
        :javax.servlet.ServletException
        :javax.servlet.http.HttpServletRequest
        :javax.servlet.http.HttpServletResponse)

(def servlet/response-codes
   {  :SC_CONTINUE                          100

      :SC_OK                                200
      :SC_CREATED                           201
      :SC_ACCEPTED                          202
      :SC_NON_AUTHORITATIVE_INFORMATION     203
      :SC_NO_CONTENT                        204
      :SC_RESET_CONTENT                     205
      :SC_PARTIAL_CONTENT                   206

      :SC_MULTIPLE_CHOICES                  300
      :SC_MOVED_PERMANENTLY                 301
      :SC_MOVED_TEMPORARILY                 302
      :SC_FOUND                             302
      :SC_SEE_OTHER                         303
      :SC_NOT_MODIFIED                      304
      :SC_USE_PROXY                         305
      :SC_TEMPORARY_REDIRECT                307

      :SC_BAD_REQUEST                       400
      :SC_UNAUTHORIZED                      401
      :SC_PAYMENT_REQUIRED                  402
      :SC_FORBIDDEN                         403
      :SC_NOT_FOUND                         404
      :SC_METHOD_NOT_ALLOWED                405
      :SC_NOT_ACCEPTABLE                    406
      :SC_PROXY_AUTHENTICATION_REQUIRED     407
      :SC_REQUEST_TIMEOUT                   408
      :SC_CONFLICT                          409
      :SC_GONE                              410
      :SC_LENGTH_REQUIRED                   411
      :SC_PRECONDITION_FAILED               412
      :SC_REQUEST_ENTITY_TOO_LARGE          413
      :SC_REQUEST_URI_TOO_LONG              414
      :SC_UNSUPPORTED_MEDIA_TYPE            415
      :SC_REQUESTED_RANGE_NOT_SATISFIABLE   416
      :SC_EXPECTATION_FAILED                417

      :SC_INTERNAL_SERVER_ERROR             500
      :SC_NOT_IMPLEMENTED                   501
      :SC_BAD_GATEWAY                       502
      :SC_SERVICE_UNAVAILABLE               503
      :SC_GATEWAY_TIMEOUT                   504
      :SC_HTTP_VERSION_NOT_SUPPORTED        505 })



;; -----------------------------------------------------------------------------
;; Java Interop
;; -----------------------------------------------------------------------------

(defn- servlet/java-enumeration-to-list
  ^{ :doc "Converts a :java.util.Enumeration to a list" }
  [enumeration]
  (into '() (. :Collections :list enumeration)))

(defn- servlet/java-stream-to-writer
  ^{ :doc "Converts a Java OutputStream to a BufferedWriter" }
  [stream encoding]
  (. :BufferedWriter :new (. :OutputStreamWriter :new stream encoding)))



;; -----------------------------------------------------------------------------
;; Request/Response utils
;; -----------------------------------------------------------------------------

(defn- servlet/get-headers
  ^{ :doc "Creates a name/value map of all the request headers." }
  [request]
  (reduce
    (fn [headers name]
      (assoc headers
        (str/lower-case name)
        (->> (. request getHeaders name)
             (servlet/java-enumeration-to-list) ;
             (str/join ","))))
    {}
    (servlet/java-enumeration-to-list (. request getHeaderNames))))

(defn- servlet/get-content-length
  ^{ :doc "Returns the content length, or nil if there is no content." }
  [request]
  (let [length (. request getContentLength)]
    (if (>= length 0) length)))

(defn- servlet/get-client-cert
  ^{ :doc "Returns the SSL client certificate of the request, if one exists." }
  [request]
  (first (. request getAttribute "javax.servlet.request.X509Certificate")))

(defn- servlet/set-response-headers
  ^{ :doc "Update a HttpServletResponse with a map of headers." }
  [response headers]
  (docoll
    (fn [[key val-or-vals]]
        (if (string? val-or-vals)
           (. response setHeader key val-or-vals)
           (docoll (fn [val] (. response setHeader key val-or-vals)) val)))
    headers)
  ; Some headers must be set through specific methods
  (let [content-type (get headers "Content-Type")]
     (when content-type
        (. response setContentType content-type))))

(defn- servlet/make-output-stream
  [response  async-context]
  (let [os (. response :getOutputStream)]
    (if (nil? async-context)
      os
      (. :FilterOutputStreamCloseCB :new
        os
        (proxify :Runnable
                 {:run (fn [] (. context :complete))} )))))

(defn- servlet/make-blocking-service-method [handler]
  (fn [servlet request response]
    (-<> request
         (servlet/build-request-map <>)
         (servlet/merge-servlet-keys <> servlet request response)
         (handler <>)
         (servlet/update-servlet-response response <>))))

(defn- servlet/make-async-service-method [handler]
  (fn [servlet request response]
    (let [async-context (. request :startAsync )]
      (handler
       (-> request
           (servlet/build-request-map)
           (servlet/merge-servlet-keys servlet request response))
       (fn [response-map]
         (servlet/update-servlet-response response async-context response-map))
       (fn [exception]
         (. response :sendError  500 (. exception :getMessage))
         (. async-context :complete ))))))

(defn servlet/make-service-method
  ^{ :doc (str/strip-indent """\
        Turns a handler into a function that takes the same arguments
        and has the same return value as the service method in the
        HttpServlet class.""") }
  ([handler]
   (servlet/make-service-method handler {}))
  ([handler options]
   (if (:async? options)
     (servlet/make-async-service-method handler)
     (servlet/make-blocking-service-method handler))))

(defn- servlet/response-writer [response output-stream]
  (if-let [charset (response/get-charset response)]
    (io/writer output-stream :encoding charset)
    (io/writer output-stream)))

(defn- servlet/write-body-to-stream [body response output-stream]
  (case (type body)
    :venice.String        (try-with [wr (servlet/response-writer response output-stream)]
                            (. wr :write body))
    :venice.ByteBuffer    (try-with [os output-stream]
                            (. os :write body))
    :java.io.InputStream  (try-with [os output-stream]
                            (io/copy-stream body os))
    :java.io.File         (try-with [os output-stream]
                            (io/copy-file body os))
    :default              (. :RuntimeException :new
                              (str
                                "Response stream supported for body type "
                                (type body)))))

(defn servlet/update-servlet-response
  ^{ :doc "Update the HttpServletResponse using a response map." }
  ([response response-map]
   (servlet/update-servlet-response response nil response-map))
  ([response async-context response-map]
   (let [{:keys [status headers body]} response-map]
     (when (nil? response)
       (throw (. :NullPointerException :new "HttpServletResponse is nil")))
     (when (nil? response-map)
       (throw (. :NullPointerException :new "Response map is nil")))
     (when status
       (. response setStatus status))
     (servlet/set-response-headers response headers)
     (let [output-stream (servlet/make-output-stream response async-context)]
       (servlet/write-body-to-stream body response-map output-stream)))))

(defn servlet/build-request-map
  ^{ :doc "Create the request map from the HttpServletRequest object." }
  [request]
  {:server-port        (. request :getServerPort)
   :server-name        (. request :getServerName)
   :remote-addr        (. request :getRemoteAddr)
   :uri                (. request :getRequestURI)
   :query-string       (. request :getQueryString)
   :scheme             (keyword (. request :getScheme))
   :request-method     (keyword (str/lower-case (. request :getMethod)))
   :protocol           (. request :getProtocol)
   :headers            (servlet/get-headers request)
   :content-type       (. request :getContentType)
   :content-length     (servlet/get-content-length request)
   :character-encoding (. request :getCharacterEncoding)
   :ssl-client-cert    (servlet/get-client-cert request)
   :body               (. request :getInputStream)})

 (defn servlet/merge-servlet-keys
   ^{ :doc "Associate servlet-specific keys with the request map." }
   [request-map servlet request response]
   (merge request-map
          {:servlet              servlet
           :servlet-request      request
           :servlet-response     response
           :servlet-context      (. servlet :getServletContext)
           :servlet-context-path (. request :getContextPath)}))



;; -----------------------------------------------------------------------------
;; Servlet
;; -----------------------------------------------------------------------------

(defn servlet/reply-not-found [req res]
  (. res :setStatus (:SC_NOT_FOUND servlet/response-codes))
  (. res :setContentType "text/html")
  (let [w (. res :getWriter)]
        (. w :println "<html><body><p>Not Found</p></body></html>")))

(defn servlet/reply-html [req res html]
  (. res :setStatus (:SC_OK servlet/response-codes))
  (. res :setContentType "text/html")
  (let [w (. res :getWriter)]
        (. w :println html)))

(defn servlet/create-servlet
  []
  (. :VeniceServlet :new
    (proxify :IVeniceServlet
      {
        :init (fn [config] nil)

      	:destroy (fn [] nil)

      	:doGet (fn [req res] (servlet/reply-html req res "Hello World"))

      	:doHead (fn [req res] (rservlet/eply-not-found req res))

      	:doPost (fn [req res] (servlet/reply-not-found req res))

      	:doPut (fn [req res] (servlet/reply-not-found req res))

      	:doDelete (fn [req res] (servlet/reply-not-found req res))

      	:doOptions (fn [req res] (servlet/reply-not-found req res))

      	:doTrace (fn [req res] (servlet/reply-not-found req res))

      	:getLastModified (fn [] -1)
      })))
