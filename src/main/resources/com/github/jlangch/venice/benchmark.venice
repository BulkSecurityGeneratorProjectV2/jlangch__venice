;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2019 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; Venice benchmarking

(defn
  format-time
  [t]
  (cond (< t 1000) (str/format "%.3f ns" t)
        (< t 1000000) (str/format "%.3f Âµs" (/ t 1000.0))
        (< t 1000000000) (str/format "%.3f ms" (/ t 1000000.0))
        :else (str/format "%.3f s" (/ t 1000000000.0))))

(defn
  remove-outliers
  [samples q1 q3]
  (let [iqr (- q3 q1)
        delta (long (* 3 iqr))
        low (- q1 delta)
        high (+ q3 delta)]
     (->> samples
         (filter #(not (< %1 low)))
         (filter #(not (> %1 high))))))

(defn
  print-stats
  [samples]
  (let [q (quartiles samples)
        q1 (first q)
        q2 (second q)
        q3 (third q)
        wo (remove-outliers samples q1 q3)
        outliers (- (count samples) (count wo))
        sd (standard-deviation :sample wo)]
      (printf "                      Samples : %d\n" (count samples))
      (printf "          Execution time mean : %s\n" (format-time q2))
      (printf " Execution time std-deviation : %s\n" (format-time sd))
      (printf "Execution time lower quartile : %s (25%%)\n" (format-time q1))
      (printf "Execution time upper quartile : %s (75%%)\n" (format-time q3))
      (printf "                     Outliers : %d\n" outliers)))

(defmacro
   ^{ :arglists '("(benchmark expr warmup-iterations iterations)")
      :doc "Benchmarks the given expression. \n\nRuns the benchmark in 4 phases: \n   1. Runs the expr in a warmup phase to allow the HotSpot compiler to do optimizations. \n   2. Runs the garbage collector \n   3. Runs the expression benchmark. \n   4. Prints the benchmark statistics."
      :examples '("(benchmark (+ 1 2) 120000 10000)") }

   benchmark [expr warmup-iterations iterations]

   `(do
      (printf "Warmup...\n")
      (dorun ~warmup-iterations ~expr)
      (printf "GC...\n")
      (dorun 2 (gc))
      (printf "Benchmark...\n")
      (let [samples (dobench ~iterations ~expr)]
        (printf "Analyzing...\n")
        (print-stats samples))))
