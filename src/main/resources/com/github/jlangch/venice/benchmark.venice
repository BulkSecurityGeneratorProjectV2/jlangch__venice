;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2019 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; Venice benchmarking


(defn
  bench/remove-outliers [samples q1 q3]
  (let [iqr (- q3 q1)
        delta (long (* 3 iqr))
        low (- q1 delta)
        high (+ q3 delta)]
     (filter #(and (>= %1 low) (<= %1 high)) samples)))


(defn
   bench/create-chart [data median title x-axis-title y-axis-title x-axis-decimal-pattern]
   (xchart/write-to-file
      (xchart/xy-chart
         { "samples" data
           "median" {:x [median median]
                     :y [0 (apply max (:y data))]
                     :style {:render-style :line
                             :marker-type :none }}}
         { :title title
           :render-style :line   ; :step
           :x-axis { :title x-axis-title
                     :decimal-pattern x-axis-decimal-pattern
                     :tick-mark-spacing-hint 10 }
           :y-axis { :title y-axis-title
                     :decimal-pattern "#0" }
           :theme :xchart } )
      :png ; write as PNG
      300  ; render with 300 dpi
      (io/file "benchmark.png")))


(defn
  bench/chart [stats steps]
  (load-module :xchart)
  (let [samples (:samples stats)
        sorted (sort samples)
        min (first sorted)
        max (last sorted)
        diff (- max min)
        step-width (/ diff steps)
        quantize (fn [x] (-> x (- min) (/ step-width) (floor) (* step-width) (+ min) (long)))
        data (reduce
               (fn [m x] (let [n (quantize x)]
                           (assoc m n (inc (get m n 0)))))
               (sorted-map)
               samples)
        x-scale  (cond (< min 1000) 1.0
                       (< min 1000000) 1000.0
                       (< min 1000000000) 1000000.0
                       :else 1000000000.0)
        x-unit   (cond (< min 1000) "ns"
                       (< min 1000000) "Âµs"
                       (< min 1000000000) "ms"
                       :else "s")
        x-format (cond (< min 1000) "#0" :else "#0.000")
        median (:q2 stats)]
     (printf "Quantization step width: %s \n" (format-nano-time (/ diff steps)))
     (bench/create-chart
       {:x (map #(/ %1 x-scale) (keys data)) :y (vals data)}
       (/ median x-scale)
       (str "Distribution (" (count samples) " samples)")
       x-unit
       "#"
       x-format)
     (printf "Saved 'benchmark.png' chart.\n")))


(defn
  bench/stats [samples]
  (let [q (quartiles samples)
        q1 (first q)
        q2 (second q)
        q3 (third q)
        cleaned-samples (bench/remove-outliers samples q1 q3)]
     { :samples samples
       :q1 q1
       :q2 q2
       :q3 q3
       :lower-quantile (quantile 0.025 samples)
       :higher-quantile (quantile 0.975 samples)
       :outliers-cnt (- (count samples) (count cleaned-samples))
       :standard-deviation (standard-deviation :sample cleaned-samples) }))


(defn
  bench/print-stats [stats]
  (printf "                      Samples : %d\n" (count (:samples stats)))
  (printf "          Execution time mean : %s\n" (format-nano-time (:q2 stats)))
  (printf " Execution time std-deviation : %s\n" (format-nano-time (:standard-deviation stats)))
  (printf "Execution time lower quartile : %s (25%%)\n" (format-nano-time (:q1 stats)))
  (printf "Execution time upper quartile : %s (75%%)\n" (format-nano-time (:q3 stats)))
  (printf "Execution time lower quantile : %s (2.5%%)\n" (format-nano-time (:lower-quantile stats)))
  (printf "Execution time upper quantile : %s (97.5%%)\n" (format-nano-time (:higher-quantile stats)))
  (printf "                     Outliers : %d\n" (:outliers-cnt stats)))


(defmacro
   ^{ :arglists '("(benchmark expr warmup-iterations iterations)")
      :doc "Benchmarks the given expression. \n\nRuns the benchmark in 4 phases: \n   1. Runs the expr in a warmup phase to allow the HotSpot compiler to do optimizations. \n   2. Runs the garbage collector \n   3. Runs the expression benchmark. \n   4. Analyzes and prints the benchmark statistics."
      :examples '("(benchmark (+ 1 2) 120000 10000)") }

   bench/benchmark [expr warmup-iterations iterations & options]


   (let [opts (apply hash-map options)
         chart? (:chart opts false)
         step (:step opts 100)]
    `(do
       (printf "Warmup...\n")
       (dobench ~warmup-iterations ~expr)
       (printf "GC...\n")
       (dorun 2 (gc))
       (let [_ (printf "Sampling...\n")
             samples (dobench ~iterations ~expr)
             stats (bench/stats samples)]
         (printf "Analyzing...\n")
         (bench/print-stats stats)
         (when ~chart?
           (printf "Generating chart...\n")
           (bench/chart stats ~step))))))
