;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2019 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; Venice benchmarking


(defn
  bench/remove-outliers [samples q1 q3]
  (let [iqr (- q3 q1)
        delta (long (* 3 iqr))
        low (- q1 delta)
        high (+ q3 delta)]
     (filter #(and (>= %1 low) (<= %1 high)) samples)))


(defn
   bench/create-chart [data title x-axis-title y-axis-title x-axis-decimal-pattern]
     (xchart/write-to-file
        (xchart/xy-chart
           { "test" data }
           { :title title
             :render-style :line   ; :step
             :x-axis { :title x-axis-title
                       :decimal-pattern x-axis-decimal-pattern
                       :tick-mark-spacing-hint 10 }
             :y-axis { :title y-axis-title
                       :decimal-pattern "#0" }
             :theme :xchart } )
        :png ; write as PNG
        300  ; render with 300 dpi
        (io/file "benchmark.png")))


(defn
  bench/chart [samples steps]
  (load-module :xchart)
  (let [sorted (sort samples)
        min (first sorted)
        max (last sorted)
        diff (- max min)
        quantize (fn [x] (-> x (- min) (* steps) (/ diff) (+ min)))
        data (reduce
               (fn [m x] (let [n (quantize x)]
                           (assoc m n (inc (get m n 0)))))
               (sorted-map)
               samples)
        x-scale  (cond (< min 1000) 1.0
                       (< min 1000000) 1000.0
                       (< min 1000000000) 1000000.0
                       :else 1000000000.0)
        x-unit   (cond (< min 1000) "ns"
                       (< min 1000000) "Âµs"
                       (< min 1000000000) "ms"
                       :else "s")
        x-format (cond (< min 1000) "#0" :else "#0.000")]
     (printf "Quantization step with: %s \n" (format-nano-time (/ diff steps)))
     (bench/create-chart
       {:x (map #(/ %1 x-scale) (keys data)) :y (vals data)}
       (str "Distribution (" (count samples) " samples)")
       x-unit
       "#"
       x-format)
     (printf "Saved 'benchmark.png' chart.\n")))


(defn
  bench/print-stats [samples]
  (let [q (quartiles samples)
        q1 (first q)
        q2 (second q)
        q3 (third q)
        lower-quantile (quantile 0.025 samples)
        higher-quantile (quantile 0.975 samples)
        cleaned-samples (bench/remove-outliers samples q1 q3)
        outliers-cnt (- (count samples) (count cleaned-samples))
        sd (standard-deviation :sample cleaned-samples)]
      (printf "                      Samples : %d\n" (count samples))
      (printf "          Execution time mean : %s\n" (format-nano-time q2))
      (printf " Execution time std-deviation : %s\n" (format-nano-time sd))
      (printf "Execution time lower quartile : %s (25%%)\n" (format-nano-time q1))
      (printf "Execution time upper quartile : %s (75%%)\n" (format-nano-time q3))
      (printf "Execution time lower quantile : %s (2.5%%)\n" (format-nano-time lower-quantile))
      (printf "Execution time upper quantile : %s (97.5%%)\n" (format-nano-time higher-quantile))
      (printf "                     Outliers : %d\n" outliers-cnt)))


(defmacro
   ^{ :arglists '("(benchmark expr warmup-iterations iterations)")
      :doc "Benchmarks the given expression. \n\nRuns the benchmark in 4 phases: \n   1. Runs the expr in a warmup phase to allow the HotSpot compiler to do optimizations. \n   2. Runs the garbage collector \n   3. Runs the expression benchmark. \n   4. Analyzes and prints the benchmark statistics."
      :examples '("(benchmark (+ 1 2) 120000 10000)") }

   bench/benchmark [expr warmup-iterations iterations & options]


   (let [opts (apply hash-map options)
         chart? (:chart opts false)
         step (:step opts 100)]
    `(do
       (printf "Warmup...\n")
       (dobench ~warmup-iterations ~expr)
       (printf "GC...\n")
       (dorun 2 (gc))
       (let [_ (printf "Sampling...\n")
             samples (dobench ~iterations ~expr)]
         (printf "Analyzing...\n")
         (bench/print-stats samples)
         (when ~chart?
           (printf "Generating chart...\n")
           (bench/chart samples ~step))))))
