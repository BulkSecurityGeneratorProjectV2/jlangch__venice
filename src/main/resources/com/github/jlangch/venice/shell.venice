;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2020 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; Shell utilities
;;;;                                                         macos  unix windows
;;;;   (open url)                                              x      x     x
;;;;   (open-macos-app name)                                   x
;;;;   (diff file1 file2)                                      x      x     x
;;;;   (kill pid & options)                                    x      x     x
;;;;   (process-running? pid)                                  x      x     x
;;;;   (wait-for-process-exit pid timeout)                     x      x     x


(ns shell)


(defn
  ^{ :arglists '("(require-mac-or-linux)")
     :doc """
          Validates if the OS is Mac OSX or Linux, throws an exception if not.
          """
     :examples '(
          "(shell/require-mac-or-linux)") }

  require-mac-or-linux []

  (when-not (or (os-type? :mac-osx) (os-type? :linux))
    (throw (venice-exception "Can only run on Mac OSX or Linux!"))))


(defn
  ^{ :arglists '("(diff file1 file2)")
     :doc "Compare two files and print the differences."
     :examples '("""(diff "/tmp/x.txt" "/tmp/y.txt")""") }

  diff [file1 file2]

  (case (os-type)
    :mac-osx (sh "diff" (str file1) (str file2))
    :linux   (sh "diff" (str file1) (str file2))
    :windows (sh "cmd" "/C" "FC" (str file1) (str file2))))


(defn
  ^{ :arglists '("(open url)")
     :doc "Opens a file or an url with the associated application."
     :examples '(
          """(shell/open "img.png")"""
          """(shell/open "https://www.heise.de/")""") }

  open [url]

  (let [url (str url)]
    (case (os-type)
      :mac-osx (sh "/usr/bin/open" url)
      :linux   (sh "/usr/bin/xdg-open" url)
      :windows (sh "cmd" "/C" "start" url))))


(defn
  ^{ :arglists '("(open-macos-app name)")
     :doc "Opens a Mac OSX applicaton application."
     :examples '(
          """(shell/open-macos-app "ArangoDB")""") }

  open-macos-app [name]

  (when-not (os-type? :mac-osx)
    (throw (venice-exception "Can only open a Mac OSX applicaton on Mac OSX!")))

  (sh "/usr/bin/open" "-a" name))


(defmulti
  ^{ :arglists '("(kill pid & options)")
     :doc """
          Kills a process by the process' pid.

          Options are
            :force     If true forces the process to be killed (-SIGKILL on Unix
                       like OSs)
            :throw-ex  If true throw an exception if the exit code is not equal
                       to zero, if false returns the exit code. Defaults to
                       false. It's recommended to use (with-sh-throw (sh "foo"))
                       instead.

          Returns a map of
               :exit => exit code
               :out  => captured stdout
               :err  => captured stderr
          """
     :examples '(
          "(shell/kill 123)"
          "(shell/kill \"123\")"
          "(shell/kill 123 :force true"
          "(shell/kill 123 :force true :throw-ex false") }

  kill (fn [pid & options] (os-type)))


(defmulti
  ^{ :arglists '("(process-running? pid)")
     :doc """
          Returns true if the pid represents a running process, false otherwise.
          """
     :examples '(
          "(shell/process-running? 123)"
          "(shell/process-running? \"123\")") }

  process-running? (fn [pid] (os-type)))


(defn
  ^{ :arglists '("(wait-for-process-exit pid timeout)")
     :doc """
          Waits until the process with the pid exits. Waits max timeout seconds.
          Returns nil if the process exits before reaching the timeout, else
          the pid is returned.
          """
     :examples '(
          "(shell/wait-for-process-exit 12345 20)"
          "(shell/wait-for-process-exit \"12345\" 20)") }

  wait-for-process-exit [pid timeout]

  (loop [secs timeout]
    (when (and (pos? secs) (process-running? pid))
      (sleep 1 :seconds)
      (recur (dec secs))))
  (if (process-running? pid) pid nil))



;; -----------------------------------------------------------------------------
;; process-running? defmethod implementations
;; -----------------------------------------------------------------------------

(defmethod process-running? :mac-osx [pid]
  (if (some? pid)
    (->> (sh "ps" "-ef" :throw-ex true)
         (:out)
         (str/split-lines)
         (map #(second (str/split (str/trim %) " +")))
         (filter #(== % (str pid)))
         (not-empty?))
  false))

(defmethod process-running? :linux [pid]
  (if (some? pid)
    (->> (sh "ps" "-ef" :throw-ex true)
         (:out)
         (str/split-lines)
         (map #(second (str/split (str/trim %) " +")))
         (filter #(== % (str pid)))
         (not-empty?))
  false))

(defmethod process-running? :windows [pid]
  (if (some? pid)
    (->> (sh "tasklist")
         (:out)
         (str/split-lines)
         (map #(second (str/split (str/trim %) " +")))
         (filter #(== % (str pid)))
         (not-empty?))
  false))


;; -----------------------------------------------------------------------------
;; kill defmethod implementations
;; -----------------------------------------------------------------------------

(defmethod kill :mac-osx [pid & options]
  (let [opts     (apply hash-map options)
        signal   (if (get opts :force false) "-SIGINT" "-SIGKILL")
        throw-ex (get opts :throw-ex true)]
    (sh "kill" signal pid :throw-ex throw-ex)))


(defmethod kill :linux [pid & options]
  (let [opts     (apply hash-map options)
        signal   (if (get opts :force false) "-SIGINT" "-SIGKILL")
        throw-ex (get opts :throw-ex true)]
    (sh "kill" signal pid :throw-ex throw-ex)))


(defmethod kill :windows [pid & options]
  (let [opts     (apply hash-map options)
        force    (if (get opts :force false) "/F" "")
        throw-ex (get opts :throw-ex true)]
    (sh "cmd" "/C" "taskkill ${force} /PID ${pid}" :throw-ex throw-ex)))
