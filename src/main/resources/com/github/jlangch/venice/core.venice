;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2019 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; Venice core macros & functions


(ns core)

(defmacro
   ^{ :arglists '("(comment & body)")
      :doc "Ignores body, yields nil"
      :examples (list (str/strip-margin
                        "(comment
                        |   (println 1)
                        |   (println 5))" )) }

   comment [& body] nil)


(defmacro
   ^{ :arglists '("(assert expr)" "(assert expr message)")
      :doc "Evaluates expr and throws an exception if it does not evaluate to logical true." }

   assert [expr message]

   `(if ~message
       (when-not ~expr
           (throw (. :com.github.jlangch.venice.AssertionException
                     :new
                     (str "Assert failed (" ~message "): " (pr-str '~expr)))))
       (when-not ~expr
           (throw (. :com.github.jlangch.venice.AssertionException
                     :new
                     (str "Assert failed: " (pr-str '~expr)))))))


(defmacro
   ^{ :arglists '("(defn name [args*] condition-map? expr*)" "(defn name ([args*] condition-map? expr*)+)")
      :doc "Same as (def name (fn name [args*] condition-map? expr*)) or (def name (fn name ([args*] condition-map? expr*)+))"
      :examples '("(defn sum [x y] (+ x y))" "(defn sum [x y] { :pre [(> x 0)] } (+ x y))") }

   defn [name & forms]

   (if (vector? (first forms))
      `(def ~name (fn ~name ~(first forms) ~@(rest forms)))
      `(def ~name (fn ~name ~@forms))))


(defmacro
  ^{ :arglists '("(defn- name [args*] condition-map? expr*)" "(defn- name ([args*] condition-map? expr*)+)")
     :doc "Same as defn, yielding non-public def"
     :examples '("(defn- sum [x y] (+ x y))") }

   defn- [name & forms]

   (list* `defn (with-meta name (assoc (meta name) :private true)) forms))


(defmacro
   ^{ :arglists '("(and x)" "(and x & next)")
      :doc "Ands the predicate forms"
      :examples '("(and true true)", "(and true false)") }

   and

   ([] true)
   ([x] x)
   ([x & next] `(let [cond_ ~x]
                   (if cond_ (and ~@next) cond_))))


(defmacro
   ^{ :arglists '("(or x)" "(or x & next)")
      :doc "Ors the predicate forms"
      :examples '("(or true false)", "(or false false)") }

   or

   ([] false)
   ([x] x)
   ([x & next] `(let [cond_ ~x]
                   (if cond_ cond_ (or ~@next)))))


(defmacro
   ^{ :arglists '("(cond & clauses)")
      :doc "Takes a set of test/expr pairs. It evaluates each test one at a time. If a test returns logical true, cond evaluates and returns the value of the corresponding expr and doesn't evaluate any of the other tests or exprs. (cond) returns nil."
      :examples (list (str/strip-margin
                        """(let [n 5]
                          |     (cond
                          |        (< n 0) "negative"
                          |        (> n 0) "positive"
                          |        :else "zero"))""" )) }

   cond [& clauses]

   (when clauses
        (list 'if (first clauses)
            (if (rest clauses)
                (second clauses)
                (throw "cond requires an even number of forms"))
            (cons 'cond (rest (rest clauses))))))


(defmacro
   ^{ :arglists '("(case expr & clauses)")
      :doc "Takes an expression and a set of clauses. Each clause takes the form of test-constant result-expr"
      :examples (list (str/strip-margin
                        "(case (+ 1 9)
                        |   10  :ten
                        |   20  :twenty
                        |   30  :thirty
                        |   :dont-know)" )) }

      ;; rewrites to (let [e (+ 1 9)]
      ;;                (cond
      ;;                  (== e 10) :ten
      ;;                  (== e 20) :twenty
      ;;                  (== e 30) :thirty
      ;;                  :else :dont-know))

   case [expr & clauses]

   (let [expr-sym (gensym "expr_")
         default_ (if (odd? (count clauses)) (last clauses) nil)
         pairs_ (partition 2 (if (odd? (count clauses)) (butlast clauses) clauses))]
      `(let [~expr-sym ~expr]
         (cond
            ~@(mapcat (fn [[test-const_ result-expr_]]
                          `((== ~expr-sym ~test-const_) ~result-expr_))
                      pairs_)
            :else ~default_))))


(defmacro
   ^{ :arglists '("(if-not then)", "(if-not then else)")
      :doc "Evaluates test. If logical false, evaluates and returns then expr, otherwise else expr, if supplied, else nil."
      :examples '("(if-not (== 1 2) 100 0)", "(if-not (== 1 2) 100)") }

   if-not

   ([test then] `(if-not ~test ~then nil))
   ([test then else] `(if (not ~test) ~then ~else)))


(defmacro
   ^{ :arglists '("(when test & body)")
      :doc "Evaluates test. If logical true, evaluates body in an implicit do."
      :examples '("(when (== 1 1) true)") }

   when [test & body]

   (list 'if test (cons 'do body)))


(defmacro
   ^{ :arglists '("(when-not test & body)")
      :doc "Evaluates test. If logical false, evaluates body in an implicit do."
      :examples '("(when-not (== 1 2) true)") }

   when-not [test & body]

   (list 'if test nil (cons 'do body)))


(defmacro
   ^{ :arglists '("(if-let bindings then)" "(if-let bindings then else)")
      :doc "bindings is a vector with 2 elements: binding-form test. \nIf test is true, evaluates then with binding-form bound to the value of test, if not, yields else"
      :examples (list (str/strip-margin
                        """(if-let [value (* 100 2)]
                          |    (str "The expression is true. value=" value)
                          |    (str "The expression is false."))""" )) }

   if-let [bindings then else]

   (let [form (first bindings) tst (second bindings)]
     `(let [temp_ ~tst]
        (if temp_
          (let [~form temp_]
            ~then)
          ~else))))


(defmacro
   ^{ :arglists '("(dotimes bindings & body)")
      :doc "Repeatedly executes body with name bound to integers from 0 through n-1."
      :examples '("""(dotimes [n 3] (println (str "n is " n)))""" ) }

   dotimes [bindings & body]

   (let [i (first bindings)
         n (second bindings)]
       `(let [k (long ~n)]
           (loop [~i 0]
              (when (< ~i k)
                 ~@body
                 (recur (inc ~i)))))))


(defmacro
   ^{ :arglists '("(while test & body)")
      :doc "Repeatedly executes body while test expression is true. Presumes some side-effect will cause test to become false/nil. Returns nil"
      :examples (list (str/strip-margin
                        "(do
                        |   (def a (atom 5))
                        |   (while (pos? (deref a))
                        |          (do (println (deref a)) (swap! a dec))))" )) }

   while [test & body]

   `(loop []
        (when ~test
            ~@body
            (recur))))


(defmacro
   ^{ :arglists '("(doto x & forms)")
      :doc "Evaluates x then calls all of the methods and functions with the value of x supplied at the front of the given arguments. The forms are evaluated in order. Returns x."
      :examples (list (str/strip-margin
                        "(doto (. :java.util.HashMap :new)
                        |      (. :put :a 1)
                        |      (. :put :b 2))" )) }

   doto [x & forms]

   (let [gx (gensym)]
       `(let [~gx ~x]
          ~@(map (fn [f] `(~(first f) ~gx ~@(rest f))) forms)
          ~gx)))


(defmacro
   ^{ :arglists '("(-> x & forms)")
      :doc "Threads the x through the forms. Inserts x as the second item in the first form, making a list of it if it is not a list already. If there are more forms, inserts the first form as the second item in second form, etc."
      :examples (list "(-> 5 (+ 3) (/ 2) (- 1))"

                      (str/strip-margin
                        """(do
                          |   (def person
                          |        {:name "Peter Meier"
                          |         :address {:street "Lindenstrasse 45"
                          |                   :city "Bern"
                          |                   :zip 3000}})
                          |
                          |   (-> person :address :street)) """ )) }

   -> [x & forms]

   (loop [x x, forms forms]
        (if forms
            (let [form (first forms)
                  threaded (if (list? form)
                               `(~(first form) ~x ~@(empty-to-nil(rest form)))
                               (list form x))]
               (recur threaded (empty-to-nil(rest forms))))
            x)))


(defmacro
   ^{ :arglists '("(->> x & forms)")
      :doc "Threads the x through the forms. Inserts x as the last item in the first form, making a list of it if it is not a list already. If there are more forms, inserts the first form as the last item in second form, etc."
      :examples (list "(->> 5 (+ 3) (/ 32) (- 1))"

                      (str/strip-margin
                         "(->> [ {:a 1 :b 2} {:a 3 :b 4} {:a 5 :b 6} {:a 7 :b 8} ]
                         |     (map (fn [x] (get x :b)))
                         |     (filter (fn [x] (> x 4)))
                         |     (map inc)))) " )) }

   ->> [x & forms]

   (loop [x x, forms forms]
        (if forms
            (let [form (first forms)
                  threaded (if (list? form)
                               `(~(first form) ~@(empty-to-nil(rest form)) ~x)
                               (list form x))]
               (recur threaded (empty-to-nil(rest forms))))
            x)))


(defmacro
   ^:private

   ;; serves the macro -<>. Inserts x in place of '<>' in form

   -<>* [form x]

   (let [substitute-pos (fn [form_] (replace {'<> x} form_))
         count-pos (fn [form_] (count (filter #(== % '<>) form_)))
         c (cond
              (or (set? form) (list? form) (vector? form)) (count-pos form)
              (map? form) (count-pos (mapcat concat form))
              :otherwise 0)]
      (cond
         (not (== c 1))   (throw (. :VncException :new "-<> macro: one position per form is required."))
         (symbol? form)   `(~form ~x)
         (vector? form)   (substitute-pos form)
         (map? form)      (apply hash-map (mapcat substitute-pos form))
         :else            `(~(first form) ~@(substitute-pos (rest form))))))

(defmacro
   ^{ :arglists '("(-<> x & forms)")
      :doc "Threads the x through the forms. Inserts x at position of the <> symbol of the first form, making a list of it if is not a list already. If there are more forms, inserts the first form at position of the <> symbol in second form, etc."
      :examples (list (str/strip-margin
                        "(-<> 5
                        |     (+ <> 3)
                        |     (/ 2 <>)
                        |     (- <> 1))" )) }

   -<>

   ([x] x)
   ([x form] `(-<>* ~form ~x))
   ([x form & forms] `(-<> (-<> ~x ~form) ~@forms)))


(defmacro
   ^{ :arglists '("(as-> expr name & forms)")
      :doc "Binds name to expr, evaluates the first form in the lexical context of that binding, then binds name to that result, repeating for each successive form, returning the result of the last form. This allows a value to thread into any argument position."
      :examples (list (str/strip-margin
                        ";allows to use arbitrary positioning of the argument
                        |(as-> [:foo :bar] v
                        |      (map name v)
                        |      (first v)
                        |      (str/subs v 1))" )
                      (str/strip-margin
                        ";allows the use of if statements in the thread
                        |(as-> {:a 1 :b 2} m
                        |      (update m :a #(+ % 10))
                        |      (if true
                        |        (update m :b #(+ % 10))
                        |         m))" ) ) }

   as-> [expr name & forms]

   `(let [~name ~expr
          ~@(interleave (repeat (count forms) name) (butlast forms))]
       ~(if (empty? forms)
            name
            (last forms))))


(defmacro
   ^{ :arglists '("(list-comp seq-exprs body-expr)")
      :doc "List comprehension. Takes a vector of one or more binding-form/collection-expr pairs, each followed by zero or more modifiers, and yields a collection of evaluations of expr. Supported modifiers are: :when test."
      :examples '("(list-comp [x (range 10)] x)"
                  "(list-comp [x (range 5)] (* x 2))"
                  "(list-comp [x (range 10) :when (odd? x)] x)"
                  "(list-comp [x (range 10) :when (odd? x)] (* x 2))"
                  "(list-comp [x (list \"abc\") y [0 1 2]] [x y])") }

   list-comp [[binding_ coll-expr & bindings] body-expr]

   (cond (not binding_)
         `(list ~body-expr)

         (== :when binding_)
         `(when ~coll-expr (list-comp ~bindings ~body-expr))

         :else
         `(mapcat (fn [~binding_] (list-comp ~bindings ~body-expr))
                  ~coll-expr)))


(defmacro
   ^{ :arglists '("(time expr)")
      :doc "Evaluates expr and prints the time it took.  Returns the value of expr."
      :examples '("(time (+ 100 200))") }

   time [expr]

   `(let [start_ (nano-time)
          ret_ ~expr
          end_ (nano-time)
          elapsed_ (- end_ start_)]
       (if (< elapsed_ 1000000)
          (printf "Elapsed time: %.2f us\n" (/ elapsed_ 1000.0))
          (printf "Elapsed time: %.2f ms\n" (/ elapsed_ 1000000.0)))
       ret_))


(defmacro
   ^{ :arglists '("(perf expr warmup-iterations test-iterations)")
      :doc "Performance test with the given expression. \n\nRuns the test in 3 phases: \n   1. Runs the expr in a warmup phase to allow the HotSpot compiler to do optimizations. \n   2. Runs the garbage collector \n   3. Runs the expression under profiling.\nReturns nil.\n\nAfter a test run metrics data can be printed with (println (prof :data-formatted))"
      :examples (list (str/strip-margin
                        """(do
                          |   (perf (+ 120 200) 12000 1000)
                          |   (println (prof :data-formatted)))""" )) }

   perf [expr warmup-iterations test-iterations]

   `(do
       (prof :on)
       (prof :clear)
       (let [fn-perf-warmup (fn _warmup [] (dorun ~warmup-iterations ~expr))
             fn-perf-gc (fn _warmup-gc [] (dorun 2 (gc)))
             fn-perf-test (fn _test [] (dorun ~test-iterations ~expr))]
           (fn-perf-warmup)
           (fn-perf-gc)
           (prof :clear-all-but ["_warmup" "_warmup-gc"])
           (fn-perf-test)
           (prof :off))
       nil))


(defmacro
   ^{ :arglists '("(load-string s)")
      :doc "Sequentially read and evaluate the set of forms contained in the string."
      :examples (list (str/strip-margin
                        """(do
                          |   (load-string "(def x 1)")
                          |   (+ x 2))""" )) }

   load-string [s]

   `(eval (read-string (str "(do " ~s ")"))))


(defmacro
   ^{ :arglists '("(load-file name)")
      :doc "Sequentially read and evaluate the set of forms contained in the file."
      :examples '() }

   load-file [f]

   `(eval (read-string (str "(do " (io/slurp ~f :encoding "UTF-8" :binary false) ")") ~f)))


(defmacro
   ^{ :arglists '("(load-classpath-file name)")
      :doc "Sequentially read and evaluate the set of forms contained in the classpath file. The function is restricted to classpath files with the extension '.venice'."
      :examples (list (str/strip-margin
                        """(do
                          |   (load-classpath-file "com/github/jlangch/venice/test.venice")
                          |   (test/test-fn "hello"))""" )) }

   load-classpath-file [f]

   `(eval (read-string (str "(do " (load-classpath-venice ~f) ")") ~f)))


(defmacro
   ^{ :arglists '("(load-module s)")
      :doc "Loads a Venice predefined extension module."
      :examples (list (str/strip-margin
                        "(do
                        |   (load-module :math))" )) }

   load-module [s]

   `(when-not (contains? core/*loaded-modules* (keyword (name ~s)))
      (let [module (read-string (str "(do " (load-core-module ~s) ")") ~s)]
        (set! core/*loaded-modules* (cons (keyword (name ~s)) core/*loaded-modules*))
        (eval module)
        (keyword (name ~s)))))


(defmacro
   ^{ :arglists '("(with-sh-dir dir & forms)")
      :doc "Sets the directory for use with sh, see sh for details."
      :examples '("""(with-sh-dir "/tmp" (sh "ls" "-l"))""") }

   with-sh-dir [dir & forms]

   `(do
      (when-not (io/exists-dir? (io/file ~dir))
         (throw (. :VncException
                   :new
                   (str/format "The dir '%s' does not exist" ~dir))))
      (binding [*sh-dir* ~dir] (do ~@forms))))


(defmacro
   ^{ :arglists '("(with-sh-env env & forms)")
      :doc "Sets the environment for use with sh, see sh for details."
      :examples '("""(with-sh-env {"NAME" "foo"} (sh "ls" "-l"))""") }

   with-sh-env [env & forms]

   `(do (binding [*sh-env* ~env] (do ~@forms))))


(defmacro
   ^{ :arglists '("(with-sh-throw forms)")
      :doc "If true throws an exception if the spawned shell process returns an exit code other than 0. If false return the exit code. Defaults to false. For use with sh, see sh for details."
      :examples '("""(with-sh-throw (sh "ls" "-l"))""") }

   with-sh-throw [& forms]

   `(do (binding [*sh-throw-ex* true] (do ~@forms))))


(defmacro
   ^{ :arglists '("(with-out-str & forms)")
      :doc "Evaluates exprs in a context in which *out* is bound to a capturing output stream. Returns the string created by any nested printing calls."
      :examples '("""(with-out-str (println "a string"))""") }

   with-out-str [& forms]

   `(do
      (binding [*out* (. :com.github.jlangch.venice.util.CapturingPrintStream :create)]
         (do ~@forms)
         (. *out* :getOutput))))


(defmacro
   ^{ :arglists '("(delay & body)")
      :doc "Takes a body of expressions and yields a Delay object that will invoke the body only the first time it is forced (with force or deref/@), and will cache the result and return it on all subsequent force calls"
      :examples '("""(do\n   (def x (delay (println "working...") 100))\n   (deref x))""") }

   delay [& body]

   `(. :com.github.jlangch.venice.impl.types.concurrent.Delay
       :new
       (fn [] (do ~@body))))


(defn
   ^{ :arglists '("(print & xs)")
      :doc "Prints to stdout, with no args, prints the empty string. With one arg x, prints x.toString(). With more than one arg, prints the concatenation of the str values of the args with delimiter ' '. Returns nil."
      :examples '("(print [10 20 30])") }

   print

   ([] nil)
   ([x] (. *out* :append (str (coalesce x "nil"))) nil)
   ([& xs] (. *out* :append (str/join " " (map #(str (coalesce % "nil")) xs))) nil))


(defn
   ^{ :arglists '("(printf fmt & args)")
      :doc "Prints formatted output, as per format"
      :examples '("""(printf "%s: %d" "abc" 100)""") }

   printf

   [fmt & args] (print (apply str/format fmt args)))


(defn
   ^{ :arglists '("(println & xs)")
      :doc "Prints to stdout with a tailing linefeed, with no args, prints the empty string. With one arg x, prints x.toString(). With more than one arg, prints the concatenation of the str values of the args with delimiter ' '. Returns nil."
      :examples '("(do (println 200) (println [10 20 30]))") }

   println

   [& xs] (do (apply print xs) (newline) nil))


(defn
   ^{ :arglists '("(newline)")
      :doc "Writes a platform-specific newline to *out*"
      :examples '("(newline)") }

   newline

   [] (do (. *out* :append "\n") nil))


(defn
   ^{ :arglists '("(flush)", "(flush os)")
      :doc "Without arg flushes the output stream that is the current value of *out*. With arg flushes the passed output stream"
      :examples '("(flush)", "(flush *out*)") }

   flush

   [os] (let [out (coalesce os *out*)] (. out :flush) nil))


(defn
   ^{ :arglists '("(not x)")
      :doc "Returns true if x is logical false, false otherwise."
      :examples '("(not true)"
                 "(not (== 1 2))") }

   not

   [x] (if x false true))

(defn
  ^{ :arglists '("(complement f)")
     :doc "Takes a fn f and returns a fn that takes the same arguments as f has the same effects, if any, and returns the opposite truth value."
     :examples '("(complement even?)"
                 "(filter (complement even?) '(1 2 3 4))") }

  complement

  [f] (fn
         ([] (not (f)))
         ([x] (not (f x)))
         ([x y] (not (f x y)))
         ([x y & zs] (not (apply f x y zs)))))

(defn
   ^{ :arglists '("(identity x)")
      :doc "Returns its argument."
      :examples '("(identity 4)"
                  "(filter identity [1 2 3 nil 4 false true 1234])") }

   identity

   [x] x)


(defn
  ^{ :arglists '("(rf-first)")
     :doc "Returns a reducing function for a transducer that returns the first item."
     :examples '("(transduce (filter number?) rf-first [false 1 2])"
                 "(transduce identity rf-first [nil 1 2])") }

  rf-first

  ([] nil)
  ([x] x)
  ([x y] (reduced y)))


(defn
  ^{ :arglists '("(rf-last)")
     :doc "Returns a reducing function for a transducer that returns the last item."
     :examples '("(transduce (filter number?) rf-last [false 1 2])"
                 "(transduce identity rf-last [1 2 1.2])") }

  rf-last

  ([] nil)
  ([x] x)
  ([x y] y))


(defn
  ^{ :arglists '("(rf-any? pred)")
     :doc "Returns a reducing function for a transducer that returns true if the predicate is true for at least one the items, false otherwise."
     :examples '("""(transduce (filter number?) (rf-any? pos?) [true -1 1 2 false])""") }

  rf-any?

  [pred] (fn
           ([] false)
           ([x] x)
           ([x y] (if (pred y) (reduced true) x))))


(defn
  ^{ :arglists '("(rf-every? pred)")
     :doc "Returns a reducing function for a transducer that returns true if the predicate is true for all the items, false otherwise."
     :examples '("""(transduce (filter number?) (rf-every? pos?) [1 2 3])""") }

  rf-every?

  [pred] (let [empty_ (volatile true)]
            (fn
              ([] false)
              ([x] x)
              ([x y] (do
                       (let [r (if @empty_ (pred y) (and x (pred y)))]
                         (reset! empty_ false)
                         (if r r (reduced r))))))))


(defn
  ^{ :arglists '("(constantly x)")
     :doc "Returns a function that takes any number of arguments and returns x."
     :examples '("(do\n  (def fix (constantly 10))\n  (fix 1 2 3))") }

  constantly

  [x] (fn [& args] x))


(defn
   ^{ :arglists '("(zipmap keys vals)")
      :doc "Returns a map with the keys mapped to the corresponding vals."
      :examples '("(zipmap [:a :b :c :d :e] [1 2 3 4 5])"
                 "(zipmap [:a :b :c] [1 2 3 4 5])") }

   zipmap [keys vals]

  (loop [omap (ordered-map)
         ks (seq keys)
         vs (seq vals)]
     (if (and (not-empty? ks) (not-empty? vs))
        (recur (assoc omap (first ks) (first vs))
               (rest ks)
               (rest vs))
        omap)))


(defn
   ^{ :arglists '("(memoize f)")
      :doc "Returns a memoized version of a referentially transparent function."
      :examples (list (str/strip-margin
                        "(do
                        |   (def fibonacci
                        |      (memoize
                        |         (fn [n]
                        |             (cond
                        |                (<= n 0) 0
                        |                (< n 2) 1
                        |                :else (+ (fibonacci (- n 1)) (fibonacci (- n 2)))))))
                        |
                        |   (time (fibonacci 25)))" )) }

   memoize

   [f]
      (let [mem_ (atom {})]
         (fn [& args]
            (if-let [e (find @mem_ args)]
               (val e)
               (let [ret (apply f args)]
                  (swap! mem_ assoc args ret)
                  ret)))))


(defn
  ^{ :arglists '("(runtime-exception msg)" "(runtime-exception msg ex)")
     :doc "Creates a java.lang.RuntimeException"
     :examples '("""(throw (runtime-exception "test"))""") }

   runtime-exception

   ([msg] (. :RuntimeException :new msg))
   ([msg ex] (. :RuntimeException :new msg ex)))


(defn
  ^{ :arglists '("(venice-exception msg)" "(venice-exception msg ex)")
     :doc "Creates a com.github.jlangch.venice.VncException"
     :examples '("""(throw (venice-exception "test"))""") }

   venice-exception

   ([msg] (. :VncException :new msg))
   ([msg ex] (. :VncException :new msg ex)))
