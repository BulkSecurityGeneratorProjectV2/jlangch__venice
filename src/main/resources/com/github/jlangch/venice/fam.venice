;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2020 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; Functors - Applicatives - Monads
;;;;
;;;; See: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
;;;;
;;;; Fluokitten:
;;;;    https://fluokitten.uncomplicate.org/articles/functors_applicatives_monads_in_pictures.html
;;;;    https://github.com/uncomplicate/fluokitten/
;;;;    https://fluokitten.uncomplicate.org/

(ns fam)


(defn just [x] { :type :just, :value x })

(defn just? [x] (and (map? x) (= :just (:type x))))

(defn unwrap [x]
  { :pre [(or (nil? x) (fam/just? x))] }
  (if (nil? x) nil (:value x)))


(defn- box-type [x]
  (cond
    (nil? x)      :fam.Nil
    (just? x)     :fam.Just
    (list? x)     :fam.List
    (vector? x)   :fam.Vector
    (set? x)      :fam.Set
    (map? x)      :fam.Map
    (atom? x)     :fam.Atom
    (volatile? x) :fam.Volatile
    (deref? x)    :fam.Dereferenceable
    :else         (type x)))


;; --------------------------------------------------------------------------
;; Functors
;; --------------------------------------------------------------------------

(defmulti fmap (fn [f functor] (fam/box-type functor)))

(defmethod fmap :fam.Nil [f functor]
  nil)

(defmethod fmap :fam.Just [f functor]
  (fam/just (f (fam/unwrap functor))))

(defmethod fmap :fam.List [f functor]
  (map f functor))

(defmethod fmap :fam.Vector [f functor]
  (into [] (map f functor)))

(defmethod fmap :fam.Set [f functor]
  (into #{} (map f functor)))

(defmethod fmap :fam.Map [f functor]
  (into {} (map (fn [[k v]] [k (f v)]) functor)))

(defmethod fmap :fam.Atom [f functor]
  (swap! functor f)
  functor)

(defmethod fmap :fam.Volatile [f functor]
  (swap! functor f)
  functor)

(defmethod fmap :fam.Dereferenceable [f functor]
  (just (f @functor)))



;; --------------------------------------------------------------------------
;; Applicatives
;; --------------------------------------------------------------------------

(defmulti fapply (fn [f-functor functor] (fam/box-type f-functor)))

(defmethod fapply :fam.Nil [f-functor functor]
  nil)

(defmethod fapply :fam.Just [f-functor functor]
  (fam/fmap (fam/unwrap f-functor) functor))

(defmethod fapply :fam.List [f-functor functor]
  (flatten (map #(fam/fmap % functor) f-functor)))

(defmethod fapply :fam.Vector [f-functor functor]
  (flatten (map #(fam/fmap % functor) f-functor)))

(defmethod fapply :fam.Atom [f-functor functor]
  (fam/fmap (deref f-functor) functor))

(defmethod fmap :fam.Volatile [f functor]
  (fam/fmap (deref f-functor) functor))

(defmethod fmap :fam.Dereferenceable [f functor]
  (fam/fmap (deref f-functor) functor))



;; --------------------------------------------------------------------------
;; Monads
;; --------------------------------------------------------------------------

(defn bind
  ([functor f] (when (some? functor) (f (fam/unwrap functor))))
  ([functor f & fs] (apply fam/bind (fam/bind functor f) fs)))
