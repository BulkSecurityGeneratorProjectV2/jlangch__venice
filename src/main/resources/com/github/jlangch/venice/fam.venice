;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2020 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; Functors - Applicatives - Monads
;;;;
;;;; See: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
;;;;
;;;; http://leonardoborges.com/writings/2012/11/30/monads-in-small-bites-part-i-functors/
;;;;
;;;; Fluokitten:
;;;;    https://fluokitten.uncomplicate.org/articles/functors_applicatives_monads_in_pictures.html
;;;;    https://github.com/uncomplicate/fluokitten/
;;;;    https://fluokitten.uncomplicate.org/

(ns fam)


(defn- box-type [x]
  (cond
    (nil? x)      :fam.Nil
    (just? x)     :fam.Just
    (list? x)     :fam.List
    (vector? x)   :fam.Vector
    (set? x)      :fam.Set
    (map? x)      :fam.Map
    (atom? x)     :fam.Atom
    (volatile? x) :fam.Volatile
    (deref? x)    :fam.Dereferenceable
    :else         (type x)))



;; -----------------------------------------------------------------------------
;; Functors
;;
;; A Functor is any type that defines how fmap applies to it.
;;
;; the types nil, just, list, set, map vector, atom, volatile, future,
;; delay, and promise are functors
;;
;; functors:  applying a function to a wrapped value using fmap
;;
;; fmap:      takes a function and a functor and returns a functor
;;
;; example:   (fmap (partial + 3) (just 2))  ; => (just 5)
;;            (fmap (partial + 3) nil)       ; => nil
;;            (fmap (partial + 3) [2 4 6])   ; => [5 7 9]
;;            (do
;;              (def foo (fmap (partial + 3) (partial + 2))))
;;              (foo 10))  ; => 15
;; -----------------------------------------------------------------------------

(defmulti fmap (fn [f functor] (fam/box-type functor)))

(defmethod fmap :fam.Nil [f functor]
  nil)

(defmethod fmap :fam.Just [f functor]
  (just (f @functor)))

(defmethod fmap :fam.List [f functor]
  (map f functor))

(defmethod fmap :fam.Vector [f functor]
  (into [] (map f functor)))

(defmethod fmap :fam.Set [f functor]
  (into #{} (map f functor)))

(defmethod fmap :fam.Map [f functor]
  (into {} (map (fn [[k v]] [k (f v)]) functor)))

(defmethod fmap :fam.Atom [f functor]
  (swap! functor f)
  functor)

(defmethod fmap :fam.Volatile [f functor]
  (swap! functor f)
  functor)

(defmethod fmap :fam.Dereferenceable [f functor]
  (just (f @functor)))



;; -----------------------------------------------------------------------------
;; Applicatives
;;
;; A Applicative is any type that defines how fapply applies to it.
;;
;; the types nil, just, list, vector, atom, volatile, future, delay, and
;; promise are applicatives
;;
;; applicatives:  applying a wrapped function to a wrapped value using fapply
;;
;; fapply:        takes an applicative and a functor and returns a functor
;;
;; example:       (fapply (just (partial + 3)) (just 2))   ; => (just 5)
;;                (fapply [(partial * 2) (partial + 3)] [1 2]) ; => [2 4 4 5]
;; -----------------------------------------------------------------------------

(defmulti fapply (fn [applicative functor] (fam/box-type applicative)))

(defmethod fapply :fam.Nil [applicative functor]
  nil)

(defmethod fapply :fam.Just [applicative functor]
  (fam/fmap @applicative functor))

(defmethod fapply :fam.List [applicative functor]
  (flatten (map #(fam/fmap % functor) applicative)))

(defmethod fapply :fam.Vector [applicative functor]
  (flatten (map #(fam/fmap % functor) applicative)))

(defmethod fapply :fam.Atom [applicative functor]
  (fam/fmap @applicative functor))

(defmethod fapply :fam.Volatile [applicative functor]
  (fam/fmap @applicative functor))

(defmethod fapply :fam.Dereferenceable [applicative functor]
  (fam/fmap @applicative functor))



;; -----------------------------------------------------------------------------
;; Monads
;;
;; A Monad is any type that defines how bind applies to it.
;;
;; the types nil, just, atom, volatile, future, delay, and
;; promise are monads
;;
;; monads:   applying a function that returns a wrapped value, to a wrapped
;;           value using bind
;;
;; bind:     takes a monad and a function that returns a monad and returns a
;;           monad
;;
;; example:  (defn half [x] (if (even? x) (just (/ x 2)) nil)))
;;
;;           (bind (just 3) half)             ; => nil
;;           (bind (just 4) half)             ; => (just 2)
;;           (bind nil half)                  ; => nil
;;           (bind (just 20) half half)       ; => (just 5)
;;           (bind (just 20) half half half)  ; => nil
;; -----------------------------------------------------------------------------

(defmulti bind (fn [monad & fs] (fam/box-type monad)))

(defmethod bind :fam.Nil [monad & fs]
  nil)

(defmethod bind :fam.Just [monad & fs]
  (if (== 1 (count fs))
    ((first fs) @monad)
    (reduce (fn [m f] (fam/bind m f)) monad fs)))

(defmethod bind :fam.Atom [monad & fs]
  (if (== 1 (count fs))
    ((first fs) @monad)
    (reduce (fn [m f] (fam/bind m f)) monad fs)))

(defmethod bind :fam.Volatile [monad & fs]
  (if (== 1 (count fs))
    ((first fs) @monad)
    (reduce (fn [m f] (fam/bind m f)) monad fs)))

(defmethod bind :fam.Dereferenceable [monad & fs]
  (if (== 1 (count fs))
    ((first fs) @monad)
    (reduce (fn [m f] (fam/bind m f)) monad fs)))
