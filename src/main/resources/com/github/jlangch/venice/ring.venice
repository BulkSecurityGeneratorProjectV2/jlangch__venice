;; Venice ring
;;
;; Venice Ring is a port of Clojure's Ring web applications library
;; (https://github.com/ring-clojure/ring).

(import :com.github.jlangch.venice.RingRedirectException
        :com.github.jlangch.venice.VncException
        :com.github.jlangch.venice.impl.servlet.IVeniceServlet
        :com.github.jlangch.venice.impl.servlet.VeniceServlet
        :com.github.jlangch.venice.impl.servlet.FilterOutputStreamCloseCB
        :java.io.BufferedWriter
        :java.io.OutputStreamWriter
        :java.lang.Exception
        :java.lang.RuntimeException
        :java.lang.NullPointerException
        :java.util.Collections
        :javax.servlet.ServletConfig
        :javax.servlet.ServletException
        :javax.servlet.http.HttpServletRequest
        :javax.servlet.http.HttpServletResponse)


;; -----------------------------------------------------------------------------
;; Utils
;; -----------------------------------------------------------------------------

(defn
  ^{ :doc "Redirect to the given URL." }
  ring/redirect
  [request url]
  (when (ring/debug? request)
        (println (str "Redirect to: " url)))
  (throw (. :RingRedirectException :new url)))

(defn
  ^{ :doc (str/strip-indent """\
        Returns the value of the specified request parameter. If the request
        did not include a parameter of the specified name, this method returns
        nil. If there are multiple parameters with the same name, this method
        returns the first parameter in the request.""" ) }
  ring/get-request-parameter
  [req name]
  (first (get (:parameters req) name)))

(defn
  ^{ :doc "Returns all the values of the specified request parameter as a list" }
  ring/get-request-parameters
  [req name]
  (get (:parameters req) name))

(defn
  ^{ :doc (str/strip-indent """\
        Returns the value of the specified request header. If the request
        did not include a header of the specified name, this method returns
        nil. If there are multiple header with the same name, this method
        returns the first header in the request.""" ) }
  ring/get-request-header
  [req name]
  (first (get (:headers req) name)))

(defn
  ^{ :doc "Returns all the values of the specified request header as a list" }
  ring/get-request-headers
  [req name]
  (get (:headers req) name))

(defn
  ^{ :doc "Returns true if debugging is turned on else false" }
  ring/debug? [req] (:debug req false))


;; -----------------------------------------------------------------------------
;; Session utils
;; -----------------------------------------------------------------------------

(defn
  ^{:doc "Invalidate the session" }
  ring/session-invalidate
  [req]
  (if-let [session (:session req)]
    (when (ring/debug? req)
          (println (str "Session invalidated: " (. session :getId))))
    (. session :invalidate)))

(defn
  ^{:doc "Get the session ID" }
  ring/session-id
  [req]
  (if-let [session (:session req)]
    (. session :getId)))

(defn
  ^{:doc "Sets a value on the session" }
  ring/session-set-value
  [req name value]
  ; wrap the Venice datatypes to prevent Java object conversions by
  ; Java Interop. We want the Venice datatype in the session
  (if-let [session (:session req)]
    (. session :setAttribute name (java-wrap value))))

(defn
  ^{:doc "Get a value from the session" }
  ring/session-get-value
  [req name]
  (if-let [session (:session req)]
    (. session :getAttribute name)))

(defn
  ^{:doc "Remove a value from the session" }
  ring/session-remove-value
  [req name]
  (if-let [session (:session req)]
    (. session :removeAttribute name)))

(defn
  ^{:doc "Returns the time (milliseconds since epoch) when this session was last accessed." }
  ring/session-last-access-time
  [req name]
  (if-let [session (:session req)]
    (. session :getLastAccessedTime)))

(defn
  ^{:doc "Returns the time (milliseconds since epoch) when this session was created." }
  ring/session-creation-time
  [req name]
  (if-let [session (:session req)]
    (. session :getCreationTime name)))


;; -----------------------------------------------------------------------------
;; Middleware
;; -----------------------------------------------------------------------------

(defn
  ^{ :doc "Identity, does effectively just delegate" }
  ring/mw-identity
  [handler]
  (fn [req] (handler req)))

(defn
  ^{ :doc "Turns handler debugging on/off" }
  ring/mw-debug
  [handler option]
  (let [on (or (nil? option) (== option :on))]
    (fn [req]
      (handler (assoc req :debug on)))))

(defn
  ^{ :doc "Prints the URI." }
  ring/mw-print-uri
  [handler]
  (fn [req]
    (when (ring/debug? req)
          (println (str "URI: " (:uri req))))
    (handler req)))

(defn
  ^{ :doc "Counts the requests and stores the value in the session." }
  ring/mw-request-counter
  [handler]
  (fn [req]
    (let [id (ring/session-id req)
          counter (inc (coalesce (ring/session-get-value req "request-counter") 0))]
      (ring/session-set-value req "request-counter" counter)
      (when (ring/debug? req)
            (println (str "Session " id ", request #: " counter))))
    (handler req)))

(defn
  ^{ :doc (str/strip-indent """\
        Adds the session to the request. If a new session is created
        the given timeout is set as the MaxInactiveInterval. If a
        timeout is not given the session will never timeout.""" ) }
  ring/mw-add-session
  [handler timeout]
  (fn [req]
    (let [session (. (:servlet-request req) :getSession true)]
      (when (. session :isNew)
        (when (ring/debug? req)
              (println (str "Session " (. session :getId) " created")))
        (. session :setMaxInactiveInterval (coalesce timeout -1)))
      (handler (assoc req :session session)))))

(defn
  ^{ :doc "Dumps the request." }
  ring/mw-dump
  [handler]
  (fn [req]
    (when (ring/debug? req)
          (println "Dump request:")
          (println "   server-port:  " (long (:server-port req)))
          (println "   server-name:  " (:server-name req))
          (println "   remote-addr:  " (:remote-addr req))
          (println "   scheme:       " (:scheme req))
          (println "   uri:          " (:uri req))
          (println "   query-string: " (:query-string req))
          (println "   method:       " (:request-method req))
          (println "   content-type: " (:content-type req))
          (println "   encoding:     " (:character-encoding req))
          (println "   context-path: " (:servlet-context-path req))
          (println "   servlet-path: " (:servlet-path req))
          (println "   session:      " (:ring/session-id req))
          (println "   headers:      ")
          (docoll #(println "     " (str (first %) ":") (second %)) (into '() (:headers req)))
          (println "   parameters:   ")
          (docoll #(println "     " (str (first %) ":") (second %)) (into '() (:parameters req)))
          (println "   cookies:      ")
          (docoll #(println "     " (str (first %) ":") (:value (second %))) (into '() (:cookies req))))
    (handler req)))

(defn
  ^{ :doc "Dumps the response." }
  ring/mw-dump-response
  [res]
  (println "Dump response:")
  (println "   content-type: " (:content-type res))
  (println "   encoding:     " (:character-encoding res))
  (println "   headers:      ")
  (docoll #(println "     " (str (first %) ":") (second %)) (into '() (:headers res)))
  (println "   cookies:      ")
  (docoll #(println "     " (str (first %) ":") (:value (second %))) (into '() (:cookies res))))


;; -----------------------------------------------------------------------------
;; Routing
;; -----------------------------------------------------------------------------

;; A route is defined by a HTTP verb, a URI filter and a handle
;; function. If multiple routes match the route with the longest
;; URI filter will be chosen.
;;
;;    (def routes [
;;      [:get "/**"                   hello-world-handler]
;;      [:get "/test/**"              test-handler]
;;      [:get "/static/images/*.png"  image-handler]
;;    ])
;;
;; Routing URI pattern filters:
;;    "/**"
;;    "/app/**"
;;    "/static/images/chart.png"
;;    "/static/images/*.png"
;;    "/static/**/*.png"
;;
;; Rigging up a Ring WEB App and starting Tomcat:
;;    (tc/run-tomcat
;;      (ring/create-servlet (-> (ring/match-routes routes)  ; >--+
;;                                                           ;    |
;;                               (ring/mw-dump)              ; ^  |
;;                               (ring/mw-request-counter)   ; |  |
;;                               (ring/mw-add-session 3600)  ; |  |
;;                               (ring/mw-print-uri)         ; |  |
;;                               (ring/mw-debug :on)))       ; +--+
;;      {:await? false})

(defn
  ^{ :doc "Compile the routes and provide the matching with the request URI" }
  ring/match-routes
  [routes]
  (let [compiled (ring/compile-routes-pattern-uri routes)]
     (fn [req]
       (let [verb (:request-method req)
             uri (:uri req)
             handler (ring/get-route-handler verb uri compiled)]
         (when (ring/debug? req)
               (println (str "Route: " verb " \"" uri "\" -> " (name handler))))
         (handler req)))))


;; -----------------------------------------------------------------------------
;; Ring Servlet
;; -----------------------------------------------------------------------------

(defn
  ^{ :doc "Create a ring servlet" }
  ring/create-servlet
 [handler]
 (. :VeniceServlet :new
   (proxify :IVeniceServlet
     { :init (fn [config] nil)
       :destroy (fn [] nil)
       :doGet (fn [req res servlet] (ring/handle req res servlet handler))
       :doHead (fn [req res servlet] (ring/handle req res servlet handler))
       :doPost (fn [req res servlet] (ring/handle req res servlet handler))
       :doPut (fn [req res servlet] (ring/handle req res servlet handler))
       :doDelete (fn [req res servlet] (ring/handle req res servlet handler))
       :doOptions (fn [req res servlet] (ring/handle req res servlet handler))
       :doTrace (fn [req res servlet] (ring/handle req res servlet handler))
       :getLastModified (fn [req] -1) })))


;; -----------------------------------------------------------------------------
;; Header utils (internal)
;; -----------------------------------------------------------------------------

(def
  ^{:doc "Pattern for pulling the charset out of the content-type header" }
  ring/regex-charset
  (regex/pattern ".*charset=([^\\s;]+).*"))

(defn-
  ^{ :doc (str/strip-indent """\
        Looks up a header in a Ring response (or request) case insensitively,
        returning the header map entry, or nil if not present.""" ) }
  ring/find-header
  [resp header-name]
  (if (java-obj? resp)
    (. resp :getHeader header-name)
    (->> (:headers resp)
         (filter #(str/equals-ignore-case? header-name (key %)))
         (first))))

(defn-
  ^{ :doc (str/strip-indent """\
        Gets the character encoding of a Ring response.
        E.g.: Content-Type: text/html; charset=utf-8""" ) }
  ring/get-charset
  [res]
  (if-let [content-type (ring/find-header res "Content-Type")]
    (let [m (regex/matcher ring/regex-charset content-type)]
      (when (regex/matches? m)
        (regex/group m 1)))))

(defn-
  ^{:doc "Return the HttpServletRequest cookies as a map" }
  ring/get-cookies
  [req]
  (let [cookies (. req :getCookies)]
    (if cookies
      (reduce (fn [m c] (assoc m (. c :getName) c)) {} cookies)
      {})))


;; -----------------------------------------------------------------------------
;; Request/Response utils (internal)
;; -----------------------------------------------------------------------------

(defn- ring/get-headers
  ^{ :doc "Creates a name/value map of all the request headers." }
  [request]
  (reduce
    (fn [headers name]
      (assoc headers
        (str/lower-case name)
        (->> (. request :getHeaders name)
             (java-enumeration-to-list) ;
             (str/join ","))))
    {}
    (java-enumeration-to-list (. request :getHeaderNames))))

(defn- ring/get-parameters
  ^{ :doc "Creates a name/value map of the request parameters." }
  [request]
  (. request :getParameterMap))

(defn-
  ^{ :doc "Returns the content length, or nil if there is no content." }
  ring/get-content-length
  [request]
  (let [length (. request :getContentLength)]
    (if (>= length 0) length nil)))

(defn-
  ^{ :doc "Returns the SSL client certificate of the request, if one exists." }
  ring/get-client-cert
  [request]
  (first (. request :getAttribute "javax.servlet.request.X509Certificate")))

(defn-
  ^{ :doc "Update a HttpServletResponse with a map of headers." }
  ring/set-response-headers
  [response headers]
  (docoll
    (fn [[key val-or-vals]]
        (if (string? val-or-vals)
          (. response :setHeader key val-or-vals)
          (docoll (fn [val] (. response :setHeader key val)) val-or-vals)))
    headers)
  ; Some headers must be set through specific methods
  (if-let [content-type (get headers "Content-Type")]
    (. response :setContentType content-type)))

(defn- ring/make-output-stream
  [response  async-context]
  (let [os (. response :getOutputStream)]
    (if (nil? async-context)
      os
      (. :FilterOutputStreamCloseCB :new
        os
        (proxify :Runnable
                 {:run (fn [] (. context :complete))} )))))

(defn- ring/make-blocking-service-method
  [handler]
  (fn [servlet request response]
    (-<> request
         (ring/build-request-map <>)
         (ring/merge-servlet-keys <> servlet request response)
         (handler <>)
         (ring/update-servlet-response response <>))))

(defn- ring/make-async-service-method
  [handler]
  (fn [servlet request response]
    (let [async-context (. request :startAsync )]
      (handler
       (-> request
           (ring/build-request-map)
           (ring/merge-servlet-keys servlet request response))
       (fn [response-map]
         (ring/update-servlet-response response async-context response-map))
       (fn [exception]
         (. response :sendError  500 (. exception :getMessage))
         (. async-context :complete ))))))

(defn
  ^{ :doc (str/strip-indent """\
        Turns a handler into a function that takes the same arguments
        and has the same return value as the service method in the
        HttpServlet class.""") }
  ring/make-service-method
  ([handler]
   (ring/make-service-method handler {}))
  ([handler options]
   (if (:async? options)
     (ring/make-async-service-method handler)
     (ring/make-blocking-service-method handler))))

(defn- ring/write-body-to-stream
  [body response output-stream]
  (cond
    (instance? :venice.String body)
        (try-with [os output-stream]
          (if-let [charset (ring/get-charset response)]
            (io/spit-stream os body :flush true :encoding charset)
                            (io/spit-stream os body :flush true)))

    (instance? :venice.ByteBuffer body)
        (try-with [os output-stream]
          (io/spit-stream os body :flush true))

    (instance? :java.io.InputStream body)
        (try-with [os output-stream]
          (io/copy-stream body os))

    (instance? :java.io.File body)
        (try-with [os output-stream]
          (io/copy-file body os))

    :else
        (try
          (. output-stream :close)
          (finally
            (. :RuntimeException :new
              (str
                "Response stream not supported for body type "
                                  (type body)))))))

(defn-
  ^{ :doc "Update the HttpServletResponse using a response map." }
  ring/update-servlet-response
  ([response response-map]
   (ring/update-servlet-response response nil response-map))
  ([response async-context response-map]
   (let [{:keys [status headers body]} response-map]
     (when (nil? response)
       (throw (. :NullPointerException :new "HttpServletResponse is nil")))
     (when (nil? response-map)
       (throw (. :NullPointerException :new "Response map is nil")))
     (when status
       (. response setStatus status))
     (ring/set-response-headers response headers)
     (let [output-stream (ring/make-output-stream response async-context)]
       (ring/write-body-to-stream body response-map output-stream)))))

(defn-
  ^{ :doc "Create the request map from the HttpServletRequest object." }
  ring/build-request-map
  [request]
  {:server-port        (. request :getServerPort)
   :server-name        (. request :getServerName)
   :remote-addr        (. request :getRemoteAddr)
   :uri                (. request :getRequestURI)
   :query-string       (. request :getQueryString)
   :scheme             (keyword (. request :getScheme))
   :request-method     (keyword (str/lower-case (. request :getMethod)))
   :protocol           (. request :getProtocol)
   :headers            (ring/get-headers request)
   :parameters         (ring/get-parameters request)
   :cookies            (ring/get-cookies request)
   :content-type       (. request :getContentType)
   :content-length     (ring/get-content-length request)
   :character-encoding (. request :getCharacterEncoding)
   :ssl-client-cert    (ring/get-client-cert request)
   :body               (. request :getInputStream)})

 (defn-
   ^{ :doc "Associate servlet-specific keys with the request map." }
   ring/merge-servlet-keys
   [request-map servlet request response]
   (merge request-map
          {:servlet              servlet
           :servlet-request      request
           :servlet-response     response
           :servlet-context      (. servlet :getServletContext)
           :servlet-path         (. request :getServletPath)
           :servlet-context-path (. request :getContextPath) }))


;; -----------------------------------------------------------------------------
;; Routing (internal)
;; -----------------------------------------------------------------------------

(defn ring/uri-regex
  ;; "/abc/**/*.png"
  ;;    1) split:     "/abc/" "**" "/" "*" ".png"
  ;;    2) escape:    "\\Q/abc/\\E" "**" "\\Q/\\E" "*" "\\Q.png\\E"
  ;;    3) translate: "\\Q/abc/\\E" ".*" "\\Q/\\E" "[^/]+" "\\Q.png\\E"
  ;;    4) join
  ;;    5) compile pattern
  [uri-filter]
  (-<> uri-filter
       (str/split <> "((?<=[*]{2})|(?=[*]{2}))")
       (map #(if (== "**" %) % (str/split % "((?<=[*])|(?=[*]))")) <>)
       (flatten <>)
       (map #(if (or (== "**" %) (== "*" %)) % (str "\\Q" % "\\E")) <>)
       (map #(if (== "**" %) ".*" %) <>)
       (map #(if (== "*" %) "[^/]+" %) <>)
       (str/join "" <>)
       (regex/pattern <>)))

(defn ring/uri-regex-params
  ;; /users/:id
  ;; /users/:id/playlists
  [uri-filter]
  (-<> uri-filter
       (str/replace-all <> (regex/pattern ":[0-9a-zA-Z_]+") ":PARAM")
       (str/split <> "((?<=:PARAM)|(?=:PARAM))")
       (map #(if (== ":PARAM" %) % (str/split % "((?<=:PARAM)|(?=:PARAM))")) <>)
       (flatten <>)
       (map #(if (== ":PARAM" %) "([0-9a-zA-Z_]+)" (str "\\Q" % "\\E")) <>)
       (str/join "" <>)
       (regex/pattern <>)))

(defn ring/uri-params
  [uri-filter]
  (let [matcher (regex/matcher (ring/uri-regex-params uri-filter))]
    (regex/find-all-groups matcher)))

(defn- ring/compile-routes-pattern-uri
  [routes ]
  (map
    (fn [r] { :verb (first r)
              :uri (second r)
              :uri-regex (ring/uri-regex (second r))
              :uri-params '()
              :len (count (second r))
              :handler (third r) })
    routes))

(defn- ring/compile-routes-parameter-uri
  [routes ]
  (map
    (fn [r] { :verb (first r)
              :uri (second r)
              :uri-regex (ring/uri-regex-params (second r))
              :uri-params (ring/uri-params (second r))
              :len (count (second r))
              :handler (third r) })
    routes))

(defn- ring/priority-route
  [routes]
  (if (empty? routes)
    nil
    (:handler (last (sort #(compare (:len %1) (:len %2)) routes)))))

(defn- ring/get-route-handler
  [verb uri routes]
  (ring/priority-route
    (filter (fn [route]
              (and (== verb (:verb route))
                   (-> (regex/matcher (:uri-regex route) uri)
                       (regex/matches?))))
      routes)))


;; -----------------------------------------------------------------------------
;; Servlet (internal)
;; -----------------------------------------------------------------------------

(defn- ring/send-not-found
  [res]
  (. res :setStatus 404)
  (. res :setContentType "text/html")
  (-> (. res :getWriter)
      (. :println (str "<html><body><p>Not Found</p></body></html>"))))

(defn- ring/send-redirect
  [req res redirect-uri]
  (. res :sendRedirect (str (. req :getContextPath) redirect-uri)))

(defn- ring/send-error
  [res]
  (. res :setStatus 500)
  (. res :setContentType "text/html")
  (-> (. res :getWriter)
      (. :println (str "<html><body><p>Internal Error</p></body></html>"))))

(defn ring/handle
  [req res servlet handler]
  (try
    (let [ring_req (-> req
                       (ring/build-request-map)
                       (ring/merge-servlet-keys servlet req res))
          ring_res (handler ring_req)]
      (if ring_res
        (do (ring/set-response-headers res (dissoc (:headers ring_res)))
            (ring/write-body-to-stream (:body ring_res) res (. res :getOutputStream)))
        (ring/send-not-found res)))
    (catch :RingRedirectException ex
      (ring/send-redirect req res (:redirectUri ex)))
    (catch :VncException ex
      (. ex :printVeniceStackTrace)
      (ring/send-error res))
    (catch :Exception ex
      (. ex :printStackTrace)
      (ring/send-error res))))
