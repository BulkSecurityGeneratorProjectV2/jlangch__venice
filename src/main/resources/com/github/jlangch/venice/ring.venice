;; Venice ring
;;
;; Venice Ring is a port of Clojure's Ring web applications library.
;;

(import :com.github.jlangch.venice.RingRedirectException
        :com.github.jlangch.venice.VncException
        :com.github.jlangch.venice.impl.servlet.IVeniceServlet
        :com.github.jlangch.venice.impl.servlet.VeniceServlet
        :com.github.jlangch.venice.impl.servlet.FilterOutputStreamCloseCB
        :java.io.BufferedWriter
        :java.io.OutputStreamWriter
        :java.lang.Exception
        :java.lang.RuntimeException
        :java.lang.NullPointerException
        :java.util.Collections
        :javax.servlet.ServletConfig
        :javax.servlet.ServletException
        :javax.servlet.http.HttpServletRequest
        :javax.servlet.http.HttpServletResponse)


;; -----------------------------------------------------------------------------
;; Header utils
;; -----------------------------------------------------------------------------
(def
  ^{:doc "Pattern for pulling the charset out of the content-type header" }
  ring/regex-charset
  (regex/pattern ".*charset=([^\\s;]+).*"))

(defn
  ^{ :doc (str/strip-indent """\
        Looks up a header in a Ring response (or request) case insensitively,
        returning the header map entry, or nil if not present.""" ) }
  ring/find-header
  [resp header-name]
  (if (java-obj? resp)
    (. resp :getHeader header-name)
    (->> (:headers resp)
         (filter #(str/equals-ignore-case? header-name (key %)))
         (first))))

(defn
  ^{ :doc (str/strip-indent """\
        Gets the character encoding of a Ring response.
        E.g.: Content-Type: text/html; charset=utf-8""" ) }
  ring/get-charset
  [res]
  (if-let [content-type (ring/find-header res "Content-Type")]
    (let [m (regex/matcher ring/regex-charset content-type)]
      (when (regex/matches? m)
        (regex/group m 1)))))

(defn
  ^{:doc "Return the HttpServletRequest cookies as a map" }
  ring/get-cookies
  [req]
  (let [cookies (. req :getCookies)]
    (if cookies
      (reduce (fn [m c] (assoc m (. c :getName) c)) {} cookies)
      {})))



;; -----------------------------------------------------------------------------
;; Session utils
;; -----------------------------------------------------------------------------

(defn
  ^{:doc "Invalidate the session" }
  ring/session-invalidate
  [req]
  (if-let [session (:session req)]
    (. session :invalidate)))

(defn
  ^{:doc "Get the session ID" }
  ring/session-id
  [req]
  (if-let [session (:session req)]
    (. session :getId)))

  (defn
    ^{:doc "Sets a value on the session" }
    ring/session-set-value
    [req name value]
    ; wrap the Venice datatypes to prevent Java object
    ; conversions by Java Interop. We want the Venice
    ; datatype in the session
    (if-let [session (:session req)]
      (. session :putValue name (java-wrap value)))) ;

  (defn
    ^{:doc "Get a value from the session" }
    ring/session-get-value
    [req name]
    (if-let [session (:session req)]
      (. session :getValue name)))

  (defn
    ^{:doc "Remove a value from the session" }
    ring/session-remove-value
    [req name]
    (if-let [session (:session req)]
      (. session :removeValue name)))


;; -----------------------------------------------------------------------------
;; Request/Response utils
;; -----------------------------------------------------------------------------

(defn- ring/get-headers
  ^{ :doc "Creates a name/value map of all the request headers." }
  [request]
  (reduce
    (fn [headers name]
      (assoc headers
        (str/lower-case name)
        (->> (. request :getHeaders name)
             (java-enumeration-to-list) ;
             (str/join ","))))
    {}
    (java-enumeration-to-list (. request :getHeaderNames))))

(defn-
  ^{ :doc "Returns the content length, or nil if there is no content." }
  ring/get-content-length
  [request]
  (let [length (. request :getContentLength)]
    (if (>= length 0) length nil)))

(defn-
  ^{ :doc "Returns the SSL client certificate of the request, if one exists." }
  ring/get-client-cert
  [request]
  (first (. request :getAttribute "javax.servlet.request.X509Certificate")))

(defn-
  ^{ :doc "Update a HttpServletResponse with a map of headers." }
  ring/set-response-headers
  [response headers]
  (docoll
    (fn [[key val-or-vals]]
        (if (string? val-or-vals)
          (. response :setHeader key val-or-vals)
          (docoll (fn [val] (. response :setHeader key val)) val-or-vals)))
    headers)
  ; Some headers must be set through specific methods
  (if-let [content-type (get headers "Content-Type")]
    (. response :setContentType content-type)))

(defn- ring/make-output-stream
  [response  async-context]
  (let [os (. response :getOutputStream)]
    (if (nil? async-context)
      os
      (. :FilterOutputStreamCloseCB :new
        os
        (proxify :Runnable
                 {:run (fn [] (. context :complete))} )))))

(defn- ring/make-blocking-service-method
  [handler]
  (fn [servlet request response]
    (-<> request
         (ring/build-request-map <>)
         (ring/merge-servlet-keys <> servlet request response)
         (handler <>)
         (ring/update-servlet-response response <>))))

(defn- ring/make-async-service-method
  [handler]
  (fn [servlet request response]
    (let [async-context (. request :startAsync )]
      (handler
       (-> request
           (ring/build-request-map)
           (ring/merge-servlet-keys servlet request response))
       (fn [response-map]
         (ring/update-servlet-response response async-context response-map))
       (fn [exception]
         (. response :sendError  500 (. exception :getMessage))
         (. async-context :complete ))))))

(defn
  ^{ :doc (str/strip-indent """\
        Turns a handler into a function that takes the same arguments
        and has the same return value as the service method in the
        HttpServlet class.""") }
  ring/make-service-method
  ([handler]
   (ring/make-service-method handler {}))
  ([handler options]
   (if (:async? options)
     (ring/make-async-service-method handler)
     (ring/make-blocking-service-method handler))))

(defn- ring/write-body-to-stream
  [body response output-stream]
  (cond
    (instance? :venice.String body)
        (try-with [os output-stream]
          (if-let [charset (ring/get-charset response)]
            (io/spit-stream os body :flush true :encoding charset)
                            (io/spit-stream os body :flush true)))

    (instance? :venice.ByteBuffer body)
        (try-with [os output-stream]
          (io/spit-stream os body :flush true))

    (instance? :java.io.InputStream body)
        (try-with [os output-stream]
          (io/copy-stream body os))

    (instance? :java.io.File body)
        (try-with [os output-stream]
          (io/copy-file body os))

    :else
        (try
          (. output-stream :close)
          (finally
            (. :RuntimeException :new
              (str
                "Response stream not supported for body type "
                                  (type body)))))))

(defn
  ^{ :doc "Update the HttpServletResponse using a response map." }
  ring/update-servlet-response
  ([response response-map]
   (ring/update-servlet-response response nil response-map))
  ([response async-context response-map]
   (let [{:keys [status headers body]} response-map]
     (when (nil? response)
       (throw (. :NullPointerException :new "HttpServletResponse is nil")))
     (when (nil? response-map)
       (throw (. :NullPointerException :new "Response map is nil")))
     (when status
       (. response setStatus status))
     (ring/set-response-headers response headers)
     (let [output-stream (ring/make-output-stream response async-context)]
       (ring/write-body-to-stream body response-map output-stream)))))

(defn
  ^{ :doc "Create the request map from the HttpServletRequest object." }
  ring/build-request-map
  [request]
  {:server-port        (. request :getServerPort)
   :server-name        (. request :getServerName)
   :remote-addr        (. request :getRemoteAddr)
   :uri                (. request :getRequestURI)
   :query-string       (. request :getQueryString)
   :scheme             (keyword (. request :getScheme))
   :request-method     (keyword (str/lower-case (. request :getMethod)))
   :protocol           (. request :getProtocol)
   :headers            (ring/get-headers request)
   :cookies            (ring/get-cookies request)
   :content-type       (. request :getContentType)
   :content-length     (ring/get-content-length request)
   :character-encoding (. request :getCharacterEncoding)
   :ssl-client-cert    (ring/get-client-cert request)
   :body               (. request :getInputStream)})

 (defn
   ^{ :doc "Associate servlet-specific keys with the request map." }
   ring/merge-servlet-keys
   [request-map servlet request response]
   (merge request-map
          {:servlet              servlet
           :servlet-request      request
           :servlet-response     response
           :servlet-context      (. servlet :getServletContext)
           :servlet-context-path (. request :getContextPath) }))



;; -----------------------------------------------------------------------------
;; Middleware
;; -----------------------------------------------------------------------------

(defn ring/mw-identity
  [handler]
  (fn [req] (handler req)))

(defn ring/mw-debug
  ^{ :doc "Turns debugging on/off" }
  [handler option]
  (let [on (or (nil? option) (== option :on))]
    (fn [req]
      (handler (assoc req :debug on)))))

(defn ring/mw-print-uri
  ^{ :doc "Prints the URI." }
  [handler]
  (fn [req]
    (when (:debug req false)
          (println (str "URI: " (:uri req))))
    (handler req)))

(defn ring/mw-request-counter
  ^{ :doc "Counts the requests and stores the value in the session." }
  [handler]
  (fn [req]
    (let [id (ring/session-id req)
          counter (inc (coalesce (ring/session-get-value req "request-counter") 0))]
      (ring/session-set-value req "request-counter" counter)
      (when (:debug req false)
            (println (str "Session " id ", request #: " counter))))
    (handler req)))

(defn
  ^{ :doc (str/strip-indent """\
        Adds the session to the request. If a new session is created
        the given timeout is set as the MaxInactiveInterval. If a
        timeout is not given the session will never timeout.""" ) }
  ring/mw-add-session
  [handler timeout]
  (fn [req]
    (let [session (. (:servlet-request req) :getSession)]
      (when (. session :isNew)
        (when (:debug req false)
              (println (str "Session " (. session :getId) " created")))
        (. session :setMaxInactiveInterval (coalesce timeout -1)))
      (handler (assoc req :session session)))))

(defn ring/mw-dump
  ^{ :doc "Dumps the request." }
  [handler]
  (fn [req]
    (when (:debug req false)
          (println "Dump request:")
          (println "   server-port:  " (long (:server-port req)))
          (println "   server-name:  " (:server-name req))
          (println "   remote-addr:  " (:remote-addr req))
          (println "   scheme:       " (:scheme req))
          (println "   uri:          " (:uri req))
          (println "   query-string: " (:query-string req))
          (println "   method:       " (:request-method req))
          (println "   content-type: " (:content-type req))
          (println "   encoding:     " (:character-encoding req))
          (println "   content-type: " (:content-type req)))
    (handler req)))



;; -----------------------------------------------------------------------------
;; Routing
;; -----------------------------------------------------------------------------

;; A route is defined by a HTTP verb, a URI filter and a handle
;; function. If multiple routes match the route with the longest
;; URI filter will be chosen.
;;
;;    (def routes [
;;      [:get "/**"                   hello-world-handler]
;;      [:get "/test/**"              test-handler]
;;      [:get "/static/images/*.png"  image-handler]
;;    ])
;;
;; Routing URI filters:
;;    "/**"
;;    "/app/**"
;;    "/static/images/chart.png"
;;    "/static/images/*.png"
;;    "/static/**/*.png"

(defn ring/uri-regex
  [uri]
  (-> uri
      (str/replace-all "?" "[?]")
      (str/replace-all "(" "[(]")
      (str/replace-all ")" "[)]")
      (str/replace-all "+" "[+]")
      (str/replace-all "." "[.]")
      (str/replace-all "**" "[@@]")
      (str/replace-all "*" "[^/]+")
      (str/replace-all "[@@]" ".*")
      (regex/pattern)))

(defn ring/compile-routes
  [routes]
  (map
    (fn [r] { :verb (first r)
              :uri (second r)
              :uri-regex (ring/uri-regex (second r))
              :len (count (second r))
              :handler (third r) })
    routes))

(defn ring/priority-route
  [routes]
  (if (empty? routes)
    nil
    (:handler (last (sort #(compare (:len %1) (:len %2)) routes)))))

(defn ring/get-route-handler
  [verb uri routes]
  (ring/priority-route
    (filter (fn [route]
              (and (== verb (:verb route))
                   (-> (regex/matcher (:uri-regex route) uri)
                       (regex/matches?))))
      routes)))

(defn ring/match-routes
  [routes]
  (let [compiled (ring/compile-routes routes)]
     (fn [req]
       (let [verb (:request-method req)
             uri (:uri req)
             handler (ring/get-route-handler verb uri compiled)]
         (when (:debug req false)
               (println (str "Route: \"" uri "\" -> " (name handler))))
         (handler req)))))



;; -----------------------------------------------------------------------------
;; Servlet
;; -----------------------------------------------------------------------------

(defn- ring/send-not-found
  [res]
  (. res :setStatus 404)
  (. res :setContentType "text/html")
  (-> (. res :getWriter)
      (. :println (str "<html><body><p>Not Found</p></body></html>"))))

(defn- ring/send-redirect
  [req res redirect-uri]
  (. res :sendRedirect (str (. req :getContextPath) redirect-uri)))

(defn- ring/send-error
  [res]
  (. res :setStatus 500)
  (. res :setContentType "text/html")
  (-> (. res :getWriter)
      (. :println (str "<html><body><p>Internal Error</p></body></html>"))))

(defn ring/handle
  [req res servlet handler]
  (try
    (let [ring_req (-> req
                       (ring/build-request-map)
                       (ring/merge-servlet-keys servlet req res))
          ring_res (handler ring_req)]
      (if ring_res
        (do (ring/set-response-headers res (dissoc (:headers ring_res)))
            (ring/write-body-to-stream (:body ring_res) res (. res :getOutputStream)))
        (ring/send-not-found res)))
    (catch :RingRedirectException ex
      (ring/send-redirect res (:redirectUri ex)))
    (catch :VncException ex
      (ring/send-error res))
    (catch :Exception ex
      (ring/send-error res))))

(defn ring/create-servlet
  [handler]
  (. :VeniceServlet :new
    (proxify :IVeniceServlet
      { :init (fn [config] nil)
        :destroy (fn [] nil)
        :doGet (fn [req res servlet] (ring/handle req res servlet handler))
        :doHead (fn [req res servlet] (ring/handle req res servlet handler))
        :doPost (fn [req res servlet] (ring/handle req res servlet handler))
        :doPut (fn [req res servlet] (ring/handle req res servlet handler))
        :doDelete (fn [req res servlet] (ring/handle req res servlet handler))
        :doOptions (fn [req res servlet] (ring/handle req res servlet handler))
        :doTrace (fn [req res servlet] (ring/handle req res servlet handler))
        :getLastModified (fn [req] -1) })))
