;; Venice ring
;;
;; Venice Ring is a port of Clojure's Ring web applications library.
;;
;; -----------------------------------------------------------------------------
;; Example
;; -----------------------------------------------------------------------------
;; (import :java.io.FileInputStream)
;;
;; (load-module :tomcat)
;; (load-module :ring)
;;
;; (defn hello-world-handler [request]
;;   { :status 200
;;     :headers { "Content-Type" "text/plain; charset=utf-8" }
;;     :body "Hello World" })
;;
;; (defn test-handler [request]
;;   { :status 200
;;     :headers { "Content-Type" "text/plain; charset=utf-8" }
;;     :body "Test" })
;;
;; (defn image-handler [request]
;;   { :status 200
;;     :headers { "Content-Type" "image/png" }
;;     :body (. :FileInputStream :new (io/file (io/user-dir) "pie.png")) })
;;
;; A route is defined by a HTTP verb, a URI filter and a handle
;; function.
;; If multiple routes match the route with the longest URI filter
;; will be chosen
;; (def routes [
;;   [:get "/**"                   hello-world-handler]
;;   [:get "/test"                 test-handler]
;;   [:get "/test/**"              test-handler]
;;   [:get "/static/images/*.png"  image-handler]
; ])
;;
;; (tc/run-tomcat
;;   (ring/create-servlet (ring/match-routes routes))
;;   {:await? false})



(import :com.github.jlangch.venice.impl.servlet.IVeniceServlet
        :com.github.jlangch.venice.impl.servlet.VeniceServlet
        :com.github.jlangch.venice.impl.servlet.FilterOutputStreamCloseCB
        :java.io.BufferedWriter
        :java.io.OutputStreamWriter
        :java.lang.RuntimeException
        :java.lang.NullPointerException
        :java.util.Collections
        :javax.servlet.ServletConfig
        :javax.servlet.ServletException
        :javax.servlet.http.HttpServletRequest
        :javax.servlet.http.HttpServletResponse)

(def ring/response-codes
   {  :SC_CONTINUE                          100

      :SC_OK                                200
      :SC_CREATED                           201
      :SC_ACCEPTED                          202
      :SC_NON_AUTHORITATIVE_INFORMATION     203
      :SC_NO_CONTENT                        204
      :SC_RESET_CONTENT                     205
      :SC_PARTIAL_CONTENT                   206

      :SC_MULTIPLE_CHOICES                  300
      :SC_MOVED_PERMANENTLY                 301
      :SC_MOVED_TEMPORARILY                 302
      :SC_FOUND                             302
      :SC_SEE_OTHER                         303
      :SC_NOT_MODIFIED                      304
      :SC_USE_PROXY                         305
      :SC_TEMPORARY_REDIRECT                307

      :SC_BAD_REQUEST                       400
      :SC_UNAUTHORIZED                      401
      :SC_PAYMENT_REQUIRED                  402
      :SC_FORBIDDEN                         403
      :SC_NOT_FOUND                         404
      :SC_METHOD_NOT_ALLOWED                405
      :SC_NOT_ACCEPTABLE                    406
      :SC_PROXY_AUTHENTICATION_REQUIRED     407
      :SC_REQUEST_TIMEOUT                   408
      :SC_CONFLICT                          409
      :SC_GONE                              410
      :SC_LENGTH_REQUIRED                   411
      :SC_PRECONDITION_FAILED               412
      :SC_REQUEST_ENTITY_TOO_LARGE          413
      :SC_REQUEST_URI_TOO_LONG              414
      :SC_UNSUPPORTED_MEDIA_TYPE            415
      :SC_REQUESTED_RANGE_NOT_SATISFIABLE   416
      :SC_EXPECTATION_FAILED                417

      :SC_INTERNAL_SERVER_ERROR             500
      :SC_NOT_IMPLEMENTED                   501
      :SC_BAD_GATEWAY                       502
      :SC_SERVICE_UNAVAILABLE               503
      :SC_GATEWAY_TIMEOUT                   504
      :SC_HTTP_VERSION_NOT_SUPPORTED        505 })



;; -----------------------------------------------------------------------------
;; Header utils
;; -----------------------------------------------------------------------------
(def ^{:doc "Pattern for pulling the charset out of the content-type header" }
  ring/regex-charset
  (regex/pattern ".*charset=([^\\s;]+).*"))

(defn ring/find-header
  ^{ :doc (str/strip-indent """\
        Looks up a header in a Ring response (or request) case insensitively,
        returning the header map entry, or nil if not present.""" ) }
  [resp header-name]
  (if (java-obj? resp)
    (. resp :getHeader header-name)
    (->> (:headers resp)
         (filter #(str/equals-ignore-case? header-name (key %)))
         (first))))

(defn ring/get-charset
  ^{ :doc (str/strip-indent """\
        Gets the character encoding of a Ring response.
        E.g.: Content-Type: text/html; charset=utf-8""" ) }
  [res]
  (if-let [content-type (ring/find-header res "Content-Type")]
    (let [m (regex/matcher ring/regex-charset content-type)]
      (when (regex/matches? m)
        (regex/group m 1)))))



;; -----------------------------------------------------------------------------
;; Request/Response utils
;; -----------------------------------------------------------------------------

(defn- ring/get-headers
  ^{ :doc "Creates a name/value map of all the request headers." }
  [request]
  (reduce
    (fn [headers name]
      (assoc headers
        (str/lower-case name)
        (->> (. request :getHeaders name)
             (ring/java-enumeration-to-list) ;
             (str/join ","))))
    {}
    (ring/java-enumeration-to-list (. request :getHeaderNames))))

(defn- ring/get-content-length
  ^{ :doc "Returns the content length, or nil if there is no content." }
  [request]
  (let [length (. request :getContentLength)]
    (if (>= length 0) length nil)))

(defn- ring/get-client-cert
  ^{ :doc "Returns the SSL client certificate of the request, if one exists." }
  [request]
  (first (. request :getAttribute "javax.servlet.request.X509Certificate")))

(defn- ring/set-response-headers
  ^{ :doc "Update a HttpServletResponse with a map of headers." }
  [response headers]
  (docoll
    (fn [[key val-or-vals]]
        (if (string? val-or-vals)
          (. response :setHeader key val-or-vals)
          (docoll (fn [val] (. response :setHeader key val)) val-or-vals)))
    headers)
  ; Some headers must be set through specific methods
  (if-let [content-type (get headers "Content-Type")]
    (. response :setContentType content-type)))

(defn- ring/make-output-stream
  [response  async-context]
  (let [os (. response :getOutputStream)]
    (if (nil? async-context)
      os
      (. :FilterOutputStreamCloseCB :new
        os
        (proxify :Runnable
                 {:run (fn [] (. context :complete))} )))))

(defn- ring/make-blocking-service-method
  [handler]
  (fn [servlet request response]
    (-<> request
         (ring/build-request-map <>)
         (ring/merge-servlet-keys <> servlet request response)
         (handler <>)
         (ring/update-servlet-response response <>))))

(defn- ring/make-async-service-method
  [handler]
  (fn [servlet request response]
    (let [async-context (. request :startAsync )]
      (handler
       (-> request
           (ring/build-request-map)
           (ring/merge-servlet-keys servlet request response))
       (fn [response-map]
         (ring/update-servlet-response response async-context response-map))
       (fn [exception]
         (. response :sendError  500 (. exception :getMessage))
         (. async-context :complete ))))))

(defn ring/make-service-method
  ^{ :doc (str/strip-indent """\
        Turns a handler into a function that takes the same arguments
        and has the same return value as the service method in the
        HttpServlet class.""") }
  ([handler]
   (ring/make-service-method handler {}))
  ([handler options]
   (if (:async? options)
     (ring/make-async-service-method handler)
     (ring/make-blocking-service-method handler))))

(defn- ring/write-body-to-stream
  [body response output-stream]
  (cond
    (instance? :venice.String body)
        (try-with [os output-stream]
          (if-let [charset (ring/get-charset response)]
            (io/spit-stream os body :flush true :encoding charset)
                            (io/spit-stream os body :flush true)))

    (instance? :venice.ByteBuffer body)
        (try-with [os output-stream]
          (io/spit-stream os body :flush true))

    (instance? :java.io.InputStream body)
        (try-with [os output-stream]
          (io/copy-stream body os))

    (instance? :java.io.File body)
        (try-with [os output-stream]
          (io/copy-file body os))

    :else
        (try
          (. output-stream :close)
          (finally
            (. :RuntimeException :new
              (str
                "Response stream not supported for body type "
                                  (type body)))))))

(defn ring/update-servlet-response
  ^{ :doc "Update the HttpServletResponse using a response map." }
  ([response response-map]
   (ring/update-servlet-response response nil response-map))
  ([response async-context response-map]
   (let [{:keys [status headers body]} response-map]
     (when (nil? response)
       (throw (. :NullPointerException :new "HttpServletResponse is nil")))
     (when (nil? response-map)
       (throw (. :NullPointerException :new "Response map is nil")))
     (when status
       (. response setStatus status))
     (ring/set-response-headers response headers)
     (let [output-stream (ring/make-output-stream response async-context)]
       (ring/write-body-to-stream body response-map output-stream)))))

(defn ring/build-request-map
  ^{ :doc "Create the request map from the HttpServletRequest object." }
  [request]
  {:server-port        (. request :getServerPort)
   :server-name        (. request :getServerName)
   :remote-addr        (. request :getRemoteAddr)
   :uri                (. request :getRequestURI)
   :query-string       (. request :getQueryString)
   :scheme             (keyword (. request :getScheme))
   :request-method     (keyword (str/lower-case (. request :getMethod)))
   :protocol           (. request :getProtocol)
   :headers            (ring/get-headers request)
   :content-type       (. request :getContentType)
   :content-length     (ring/get-content-length request)
   :character-encoding (. request :getCharacterEncoding)
   :ssl-client-cert    (ring/get-client-cert request)
   :body               (. request :getInputStream)})

 (defn ring/merge-servlet-keys
   ^{ :doc "Associate servlet-specific keys with the request map." }
   [request-map servlet request response]
   (merge request-map
          {:servlet              servlet
           :servlet-request      request
           :servlet-response     response
           :servlet-context      (. servlet :getServletContext)
           :servlet-context-path (. request :getContextPath)}))



;; -----------------------------------------------------------------------------
;; Routing
;; -----------------------------------------------------------------------------

;; A route is defined by a HTTP verb, a URI filter and a handle
;; function. If multiple routes match the route with the longest
;; URI filter will be chosen.
;;
;;    (def routes [
;;      [:get "/**"                   hello-world-handler]
;;      [:get "/test/**"              test-handler]
;;      [:get "/static/images/*.png"  image-handler]
;;    ])
;;
;; Routing URI filters:
;;    "/**"
;;    "/app/**"
;;    "/static/images/chart.png"
;;    "/static/images/*.png"
;;    "/static/**/*.png"

(defn ring/uri-regex
  [uri]
  (-> uri
      (str/replace-all "?" "[?]")
      (str/replace-all "(" "[(]")
      (str/replace-all ")" "[)]")
      (str/replace-all "+" "[+]")
      (str/replace-all "." "[.]")
      (str/replace-all "**" "[@@]")
      (str/replace-all "*" "[^/]+")
      (str/replace-all "[@@]" ".*")
      (regex/pattern)))

(defn ring/compile-routes
  [routes]
  (map
    (fn [r] { :verb (first r)
              :uri (second r)
              :uri-regex (ring/uri-regex (second r))
              :len (count (second r))
              :handler (third r) })
    routes))

(defn ring/priority-route
  [routes]
  (case (count routes)
    0      nil
    1      (:handler (first routes))
    (:handler (last (sort #(compare (:len %1) (:len %2)) routes)))))

(defn ring/get-route-handler
  [verb uri routes]
  (ring/priority-route
    (filter (fn [route]
              (and (== verb (:verb route))
                   (-> (regex/matcher (:uri-regex route) uri)
                       (regex/matches?))))
      routes)))

(defn ring/match-routes
  [routes]
  (let [compiled (ring/compile-routes routes)]
     (fn [req]
       (let [verb (:request-method req)
             uri (:uri req)
             handler (ring/get-route-handler verb uri compiled)]
         ;(println (str "route: \"" uri "\" -> " handler))
         (handler req)))))



;; -----------------------------------------------------------------------------
;; Servlet
;; -----------------------------------------------------------------------------

(defn- ring/send-text
  [res text]
  (. res :setStatus 200)
  (. res :setContentType "text/html")
  (-> (. res :getWriter)
      (. :println (str "<html><body><p>" text "</p></body></html>"))))

(defn- ring/send-not-found
  [res]
  (. res :setStatus 404)
  (. res :setContentType "text/html")
  (-> (. res :getWriter)
      (. :println (str "<html><body><p>Not Found</p></body></html>"))))

(defn ring/handle
  [req res servlet handler]
  (let [h_req (-> req
                  (ring/build-request-map)
                  (ring/merge-servlet-keys servlet req res))
        h_res (handler h_req)]
    (if h_res
      (do (ring/set-response-headers res (dissoc (:headers h_res)))
          (ring/write-body-to-stream (:body h_res) res (. res :getOutputStream)))
      (ring/send-not-found res))))

(defn ring/create-servlet
  [handler]
  (. :VeniceServlet :new
    (proxify :IVeniceServlet
      { :init (fn [config] nil)
        :destroy (fn [] nil)
        :doGet (fn [req res servlet] (ring/handle req res servlet handler))
        :doHead (fn [req res servlet] (ring/handle req res servlet handler))
        :doPost (fn [req res servlet] (ring/handle req res servlet handler))
        :doPut (fn [req res servlet] (ring/handle req res servlet handler))
        :doDelete (fn [req res servlet] (ring/handle req res servlet handler))
        :doOptions (fn [req res servlet] (ring/handle req res servlet handler))
        :doTrace (fn [req res servlet] (ring/handle req res servlet handler))
        :getLastModified (fn [] -1) })))
