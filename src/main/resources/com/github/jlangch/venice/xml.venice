;; XML parser
;;

(import :com.github.jlangch.venice.util.XMLHandler
        :com.github.jlangch.venice.util.IXMLHandler
        :java.lang.StringBuilder
        :java.io.StringReader
        :javax.xml.parsers.SAXParser
        :javax.xml.parsers.SAXParserFactory
        :org.xml.sax.InputSource)

(def-dynamic *stack*)
(def-dynamic *current*)
(def-dynamic *sb*)
(def-dynamic *state*) ; :element :chars :between

(defn
  ^{ :doc "Create a SAX parser content handler" }
  xml/handler
  []
  (let [push-content (fn [e c]
                       (assoc e :content (conj (or (:content e) []) c)))
        push-chars (fn []
                     (let [sb (str *sb*)]
                       (when (and (== *state* :chars) (str/trim-to-nil sb))
                         (set! *current* (push-content *current* sb)))))]
    (. :XMLHandler :new
      (proxify :IXMLHandler
        { :startElement
              (fn [uri local-name q-name attributes]
                (let [e {:tag q-name
                         :attributes (xml/parse-attributes attributes)} ]
                  (push-chars)
                  (set! *stack* (conj *stack* *current*))
                  (set! *current* e)
                  (set! *state* :element)
                  nil))
          :endElement
              (fn [uri local-name q-name]
                (push-chars)
                (set! *current* (push-content (peek *stack*) *current*))
                (set! *stack* (pop *stack*))
                (set! *state* :between)
                nil)
          :characters
              (fn [chars]
                (when-not (== *state* :chars)
                  (set! *sb* (. :StringBuilder :new)))
                (. *sb* :append chars)
                (set! *state* :chars)
                nil)
          :setDocumentLocator (fn [locator] nil)
          :startDocument (fn [] nil)
          :endDocument (fn [] nil)
          :startPrefixMapping (fn [prefix uri] nil)
          :endPrefixMapping (fn [prefix] nil)
          :ignorableWhitespace (fn [chars] nil)
          :processingInstruction (fn [target data] nil)
          :skippedEntity (fn [name] nil) }))))

(defn
  ^{ :doc (str/strip-indent """\
        Parses and loads the XML from the source s with the parser
        IXMLHandler handler. The source may be an InputSource,
        an InputStream, a File, or a string describing an URI.""" ) }
  xml/parse
  ([s] (xml/parse s (xml/handler)))
  ([s handler]
    (binding [*stack* []
              *current* {}
              *state* :between
              *sb* nil]
      (-> (. :SAXParserFactory :newInstance)
          (. :newSAXParser)
          (. :parse s handler))
      (first (:content *current*)))))

(defn
  ^{ :doc "Create a SAX InputSource from a string" }
  xml/str-to-input-source
  [s]
  (->> (. :StringReader :new s)
       (. :InputSource :new)))

(defn
  ^{ :doc "Parse SAX attributes into a map." }
  xml/parse-attributes
  [attributes]
  (let [len (:length attributes)]
    (when (> len 0)
      (apply merge
             (map (fn [x] { (keyword (. attributes :getQName x))
                            (. attributes :getValue x) } )
                  (range len))))))
