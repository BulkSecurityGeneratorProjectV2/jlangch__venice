;; XML parser
;;

(import :com.github.jlangch.venice.util.XMLHandler
        :com.github.jlangch.venice.util.IXMLHandler
        :com.github.jlangch.venice.util.XMLUtil
        :java.lang.StringBuilder
        :java.io.StringReader
        :org.xml.sax.InputSource)

(def-dynamic *stack*)
(def-dynamic *current*)
(def-dynamic *sb*)
(def-dynamic *state*) ; :element :chars :between

(defn
  ^{ :doc "Create a SAX parser content handler" }
  xml/handler
  []
  (let [push-content (fn [elem content]
                       (let [new (conj (or (:content elem) []) content)]
                          (assoc elem :content new)))
        push-chars (fn []
                     (let [sb (str *sb*)]
                       (when (and (== *state* :chars) (str/trim-to-nil sb))
                         (set! *current* (push-content *current* sb)))))]
    (. :XMLHandler :new
      (proxify :IXMLHandler
        { :startElement
              (fn [uri local-name q-name attributes]
                (let [attr (xml/parse-attributes attributes)
                      elem (if (nil? attr)
                             {:tag q-name }
                             {:tag q-name :attrs attr}) ]
                  (push-chars)
                  (set! *stack* (conj *stack* *current*))
                  (set! *current* elem)
                  (set! *state* :element)
                  nil))
          :endElement
              (fn [uri local-name q-name]
                (push-chars)
                (set! *current* (push-content (peek *stack*) *current*))
                (set! *stack* (pop *stack*))
                (set! *state* :between)
                nil)
          :characters
              (fn [chars]
                (when-not (== *state* :chars)
                  (set! *sb* (. :StringBuilder :new)))
                (. *sb* :append chars)
                (set! *state* :chars)
                nil)
          :setDocumentLocator (fn [locator] nil)
          :startDocument (fn [] nil)
          :endDocument (fn [] nil)
          :startPrefixMapping (fn [prefix uri] nil)
          :endPrefixMapping (fn [prefix] nil)
          :ignorableWhitespace (fn [chars] nil)
          :processingInstruction (fn [target data] nil)
          :skippedEntity (fn [name] nil) }))))

(defn
  ^{ :doc (str/strip-indent """\
        Parses and loads the XML from the source s with the parser
        XMLHandler handler. The source may be an InputSource, an
        InputStream, a File, or a string describing an URI.
        Returns a tree of XML element maps with the
        keys :tag, :attrs, and :content.""" ) }
  xml/parse
  ([s] (xml/parse s (xml/handler)))
  ([s handler]
    (binding [*stack* []
              *current* {}
              *state* :between
              *sb* nil]
      (. :XMLUtil :parse s false handler)
      (first (:content *current*)))))

(defn
  ^{ :doc (str/strip-indent """\
        Parses an XML from the string s.
        Returns a tree of XML element maps with the
        keys :tag, :attrs, and :content.""" ) }
  xml/parse-str
  ([s] (xml/parse (xml/input-source-from-str s) (xml/handler)))
  ([s handler] (xml/parse (xml/input-source-from-str s) handler)))

(defn
  ^{ :doc "Create a SAX InputSource from a string" }
  xml/input-source-from-str
  [s]
  (->> (. :StringReader :new s)
       (. :InputSource :new)))

(defn
  ^{ :doc "Parse SAX attributes into a map." }
  xml/parse-attributes
  [attributes]
  (let [len (. attributes :getLength)]
    (when (> len 0)
      (apply merge
             (map (fn [x] { (keyword (. attributes :getQName x))
                            (. attributes :getValue x) } )
                  (range len))))))
