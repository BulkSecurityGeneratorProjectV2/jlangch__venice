;; XML parser
;;

(import :com.github.jlangch.venice.util.XMLHandler
        :com.github.jlangch.venice.util.IXMLHandler
        :com.github.jlangch.venice.util.XMLUtil
        :java.lang.StringBuilder
        :java.io.StringReader
        :org.xml.sax.InputSource)

(def-dynamic *stack*)
(def-dynamic *current*)
(def-dynamic *sb*)
(def-dynamic *state*) ; :element :chars :between

(defn
  ^{ :doc "Create a SAX parser content handler" }
  xml/handler
  []
  (let [push-content (fn [e c]
                       (assoc e :content (conj (or (:content e) []) c)))
        push-chars (fn []
                     (let [sb (str *sb*)]
                       (when (and (== *state* :chars) (str/trim-to-nil sb))
                         (set! *current* (push-content *current* sb)))))]
    (. :XMLHandler :new
      (proxify :IXMLHandler
        { :startElement
              (fn [uri local-name q-name attributes]
                (let [attr (xml/parse-attributes attributes)
                      e (if (nil? attr)
                            {:tag q-name }
                            {:tag q-name :attributes attr}) ]
                  (push-chars)
                  (set! *stack* (conj *stack* *current*))
                  (set! *current* e)
                  (set! *state* :element)
                  nil))
          :endElement
              (fn [uri local-name q-name]
                (push-chars)
                (set! *current* (push-content (peek *stack*) *current*))
                (set! *stack* (pop *stack*))
                (set! *state* :between)
                nil)
          :characters
              (fn [chars]
                (when-not (== *state* :chars)
                  (set! *sb* (. :StringBuilder :new)))
                (. *sb* :append chars)
                (set! *state* :chars)
                nil)
          :setDocumentLocator (fn [locator] nil)
          :startDocument (fn [] nil)
          :endDocument (fn [] nil)
          :startPrefixMapping (fn [prefix uri] nil)
          :endPrefixMapping (fn [prefix] nil)
          :ignorableWhitespace (fn [chars] nil)
          :processingInstruction (fn [target data] nil)
          :skippedEntity (fn [name] nil) }))))

(defn
  ^{ :doc (str/strip-indent """\
        Parses and loads the XML from the source s with the parser
        XMLHandler handler. The source may be an InputSource, an
        InputStream, a File, or a string describing an URI.""" ) }
  xml/parse
  ([s] (xml/parse s (xml/handler)))
  ([s handler]
    (binding [*stack* []
              *current* {}
              *state* :between
              *sb* nil]
      (. :XMLUtil :parse s false handler)
      (first (:content *current*)))))

(defn
  ^{ :doc "Parses an XML from the string s." }
  xml/parse-str
  ([s] (xml/parse (xml/input-source-from-str s) (xml/handler)))
  ([s handler] (xml/parse (xml/input-source-from-str s) handler)))

(defn
  ^{ :doc "Create a SAX InputSource from a string" }
  xml/input-source-from-str
  [s]
  (->> (. :StringReader :new s)
       (. :InputSource :new)))

(defn
  ^{ :doc "Parse SAX attributes into a map." }
  xml/parse-attributes
  [attributes]
  ; use XMLUtil helpers to make it work on Java 8 and Java 9+
  ; reflective access to SAX classes cause problems with Java 9+
  (let [len (. :XMLUtil :getAttributesLength attributes)]
    (when (> len 0)
      (apply merge
             (map (fn [x] { (keyword (. :XMLUtil :getAttributeQName attributes x))
                            (. :XMLUtil :getAttributeValue attributes x) } )
                  (range len))))))
